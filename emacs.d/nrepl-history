;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(clojure.core/reduce + (range 1 11))" "(clojure.core/reduce + 1 (range 1 11))" "(clojure.core/reduce 1 (range 1 11))" "(last (range 1 11))" "(last (range 1 10))" "(first (range 1 10))" "(first (range 10))" "(doc range)" "(clojure.core/reduce 1 (range 10))" "(clojure.core/reduce 1 (range [1..10]))" "(clojure.core/reduce 1 (range [1...10]))" "(doc clojure.core/reduce)" "(clojore.core/reduce 1 [1...10])" "(doc reduce)" "(reduce 1 (range [1...10]))" "(reduce 1 [1...10])" "(Math/pow 3 2)" "(Math/pow 2 3)" "(doc Math/pow)" "(doc defmulti)" "(repeatedly 10 roll-dice)" "(repeatedly 10 roll-dice2)" "(defn roll-dice2 [] (+ (rand-int 7) (rand-int 7)))" "(repeatedly 10 roll-dice2)" "(defn roll-dice2 [] ((rand-int 7) (rand-int 7)))" "(repeatedly 10 roll-dice')" "(defn roll-dice' [] ((rand-int 7) (rand-int 7)))" "(doc rand-int)" "(repeatedly 10 roll-dice)" "(repeatedly 10 'roll-dice)" "(doc dotimes)" "(dotimes 10 (roll-dice))" "(repeat 10 (roll-dice))" "(roll-dice)" "(defn roll-dice [] (+ 2 (rand-int 6) (rand-int 6)))" "(for [x [1 2 3] y [1 2 3]] (println (* x y)))" "(for [x [1 2 3] y [1 2 3]] (* x y))" "(doseq [x [1 2 3] y [1 2 3]] (println (* x y)))" "(doc for)" "(doc doseq)" "(first squares)" "(def squares (clojure.core/map (fn [x] (println x) (* x x)) (range 1 100)))" "(doc clojure.core/map)" "(doc clojure/nrepl.map)" "(doc clojure/core.map)" "(doc map)" "(doc first)" "(first squares)" "(def squares (map (fn [x] (println x) (* x x)) (range 1 100)))" "(go
                 (while true
                   (println (<! hand-off))))" "(go
                 (dotimes [x 10]
                   (Thread/sleep 1000)
                   (>! hand-off x)))" "(def hand-off (chan))" "(use 'clojure.core.async)" "(use 'clojure/core.async)" "(def hand-off (chan))" "(barney)" "(exit)" "(re-find #\"red\" \"The color bred\" )" "(re-find #\"gred\" \"The color bred\" )" "(re-find \"The color bred\" #\"gred\")" "(re-find \"The color bred\" #\"gred\" \"lue\")" "(clojure.string/replace \"The color bred\" #\"gred\" \"lue\")" "(clojure.string/replace \"The color bred\" #\"red\" \"lue\")" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println (str \"Read: \" v \" from -> \" ch)))))
        (go (>! langs \"Clojure\"))
        (go (>! langs  \"Haskell\"))
        (go (>! creators \"Rob\")))
" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println (str \"Read: \" v \"from -> \" ch)))))
        (go (>! langs \"Clojure\"))
        (go (>! langs  \"Haskell\"))
        (go (>! creators \"Rob\")))
" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println (str \"Read\" v \"from\" ch)))))
        (go (>! langs \"Clojure\"))
        (go (>! langs  \"Haskell\"))
        (go (>! creators \"Rob\")))
" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from\" ch))))
        (go (>! langs \"Clojure\"))
        (go (>! langs  \"Haskell\"))
        (go (>! creators \"Rob\")))
" "(difference #{1 2 3} #{2 3 4})" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from\" ch))))
        (go (>! langs \"Clojure\"))
        (go (>! langs  \"Haskell\"))
        (go (>! creators \"Rob\")))
" "(difference #{1 2 3} #{2 3 4})" "(bit-shift-right 101 1)" "(java.util.Date.)" "(seq \"h3llo\")" "36ryq" "(seq [1 2 3])" "(doc seq)" "(seq \"h3llo\")" "36ryq" "36ryp" "(java.util.Date.)" "(bit-shift-right 101 1)" "(bit-shift-right 100 1)" "(bit-shift-right 15 1)" "(bit-shift-right 14 1)" "(bit-shift-right 13 1)" "(bit-shift-right 22 1)" "(bit-shift-left 22 -1)" "(bit-shift-left 22 2)" "(bit-shift-left 22 1)" "(doc bit-shift-left)" "(bit-shift-left 22)" "(doc difference)" "(difference #{1 2 3} #{2 3 4})" "(use 'clojure.set)" "((fn [] \"erpa\"))" "(*1)" "(fn [] \"erpa\")()" "(*1)" "(fn [] \"erpa\")" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from\" ch))))
        (go (>! langs \"Clojure\"))
        (go (>! langs  \"Haskell\"))
        (go (>! creators \"Rob\")))
" "poo" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from\" ch))))
        (go (>! langs \"Clojure\"))
        (go (>! langs  \"Haskell\"))
        (go (>! creators \"Rob\")))
" "(def poo (chan))" "(use 'clojure.core.async)" "(def poo (chan))" "(use 'clojure.core.async)" "(mod 11 4)" "(primep 3)" "(defn primep [x]
  (when (> x 1)
    (let [fac (range 2 (Math/round (Math/sqrt x)))]
      (while (not (zero? (mod x fac)))))))" "(defn primep [x]
  (when (> x 1)
    (let [fac (range 2 (Math/round (Math/sqrt x)))]
      (while (not (zerop (mod x fac)))))))" "(defn primep (x)
  (when (> x 1)
    (let [fac (range 2 (Math/round (Math/sqrt x)))]
      (while (not (zerop (mod x fac)))))))" "(mod 11 4)" "(% 11 4)" "(range 2 (Math/round (Math/sqrt 100)))" "(range 2 (Math/round (Math/sqrt 10)))" "(range 2 (Math/round (Math/sqrt x)))" "(Math/round 10.49)" "(Math/round 10.50)" "(Math/round 10.53)" "(type *1)" "(Math/round 10.03)" "(Math/floor 10.03)" "(Math/isqrt 101)" "(Math/sqrt 101)" "(Math/sqrt 2)" "(Math/sqrt. 2)" "(take 15 primes)" "(take 5 primes)" "(use 'clojure.core.async)" "(use 'clojure/core.async)" "(use 'clojure.async)" "(use 'clojure.core.async)" "(let [langs (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from\" ch))))
            (go (>! langs \"Clojure\"))
            (go (>! langs  \"Haskell\"))
            (go (>! creators \"Rob\")))
" "(let [lang (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from\" ch))))
            (go (>! langs \"Clojure\"))
            (go (>! langs  \"Haskell\"))
            (go (>! creators \"Rob\")))
" "(let [lang (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from\" chan))))
            (go (>! langs \"Clojure\"))
            (go (>! langs  \"Haskell\"))
            (go (>! creators \"Rob\")))
" "(let [lang (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])]
                    (println \"Read\" v \"from ch\"))))
            (go (>! langs \"Clojure\"))
            (go (>! langs  \"Haskell\"))
            (go (>! creators \"Rob\")))" "(let [lang (chan)
            creators (chan)]
        (go (while true
              (let [[v ch] (alts! [langs creators])
                    (println \"Read\" v \"from ch\")))))
            (go (>! langs \"Clojure\"))
            (go (>! langs  \"Haskell\"))
            (go (>! creators \"Rob\")))" "(let [lang (chan)])" "@views" "(doall (map (fn [_] (send views inc)) (range 1000)))" "@views" "(send views inc)" "(def views (agent 0))" "(doc assoc)" "(doc swap!)" "(first '(((me))))" "(first '((me)))" "(first '(me))" "(first [me])" "(car [me])" "(map bark [pup pup2])" "(apply bark [pup pup2])" "(bark pup2)" "(def pup2 (->Dog \"arf\"))" "(bark pup2)" "(def pup2 \"arf\")" "(bark pup)" "(->Dog \"arf\")" "(bark pup)" "(def pup (->Dog \"woof\"))" "(defrecord Dog [sound] Barking (bark [self] (str (:sound self) \"!!\")))" "(defprotocol Barking (bark [self]))" "(clojure.repl/doc map-indexed)" "(keyword (str/join(interpose \\-(map str/lower-case(str/split \"ErpaDerpa\" cc)))))" "(keyword (str/join(interpose \\-(map str/lower-case(str/split \"erpaDerpa\" cc)))))" "(str/join(interpose \\-(map str/lower-case(str/split \"erpaDerpa\" cc))))" "(str/join(partial interpose \\-(map str/lower-case(str/split \"erpaDerpa\" cc))))" "(map str/lower-case(str/split \"erpaDerpa\" cc))" "(str/join(partial interpose \\-(partial map str/lower-case(str/split \"erpaDerpa\" cc))))" "(str/join(partial interpose \\-(str/lower-case(str/split \"erpaDerpa\" cc))))" "(partial interpose \\-(str/lower-case(str/split \"erpaDerpa\" cc)))" "(str/lower-case(str/split \"erpaDerpa\" cc))" "(str/split \"erpaDerpa\" cc)" "(str/split \"ErpaDerpa\" cc)" "(require '[clojure.string :as str])" "(require '[clojure/string :as str])" "(require 'clojure/string :as str)" "(type cc)" "(def cc #\"(?<=[a-z])(?=[A-Z])\")" "(apply + 10 100 nums)" "(apply + 10 nums)" "(reduce + nums)" "(clojure.repl/doc reduce)" "(clojure.repl/doc apply)" "(apply + nums)" "(def nums [1 2 3 4 5])" "(import 'javax.sound.midi.MidiSystemErpa)" "(import 'javax.sound.midi.MidiSystem)" "(class StringBuilder)" "(type StringBuilder)" "(import (java.io FileInputStream InputStreamReader BufferedReader))" "(import (java.io FileInputStream))" "(import java.io StringBuilder)" "(type StringBuilder.)" "(type Stringbuilder.)" "(clojure.repl/doc atom)" "(fibo)" "*print-length*" "(set! *print-length* 10)" "(take 10 (fibo))" "(defn fibo [] (map first (iterate (fn [[a b]] [b (+ a b)]) [0N 1N])))" "(take 10 (fibo))" "*print-length*" "(take 10 (fibo))" "(take 9 (fibo))" "(take 5 (fibo))" "(take 5 fibo)" "(defn fibo [] (map first (iterate (fn [[a b]] [b (+ a b)]) [0N 1N])))" "(defn fibo [] (map first (iterate (fn [[a b]]) [b (+ a b)]) [0N 1N]))" "(defn fibo [] (map first (iterate (fn [[a b]) [b (+ a b)]) [0N 1N])))" "(clojure.repl/doc iterate)" "(take 10 (lazy-seq-fibo))" "(nth (lazy-seq-fibo) 4)" "(nth (lazy-seq-fibo) 0)" "(nth (lazy-seq-fibo) 9)" "(lazy-seq-fibo 9)" "(defn lazy-seq-fibo
                       ([]
                          (concat [0 1] (lazy-seq-fibo 0N 1N)))
                       ([a b]
                          (let [n (+ a b)]
                            (lazy-seq
                             (cons n (lazy-seq-fibo b n))))))" "(clojure.repl/doc rem)" "(doc rem)" "(tail-fibo 9)" "(tail-fibo 0)" "(tail-fibo 1)" "(tail-fibo 2)" "(tail-fibo 3)" "(tail-fibo 4)" "(defn tail-fibo [n]
                       (letfn [(fib
                                 [current next n]
                                 (if (zero? n)
                                   current
                                   (fib next (+ current next) (dec n))))]
                         (fib 0N 1N n)))" "(defn tail-fibo [n]
                       (letfn [(fib
                                 [current next n]
                                 (if (zero? n)
                                   curent
                                   (fib next (+ current next) (dec n))))]
                         (fib 0N 1N n)))" "'erpa" "(clojure.repl/doc inc')" "(clojure.repl/doc inc)" "(run* [q] (conso 1 [2 3] q))" "(clojure.repl/doc conso)" "(conj '(2 3) 1)" "(conj (2 3) 1)" "(clojure.repl/doc conj)" "(clojure.repl/doc cons)" "(user/doc cons)" "(doc cons)" "(ns logic-tutorial.tut1 (:use (clojure pprint repl)))" "(doc cons)" "(conj [2 3] 1)" "(conj 1 [2 3])" "(cons 1 [2 3])" "(cons 1 (2 3))" "(cons 1 '(2 3))" "(run* [q] (conde [(== q 1)] [(== q 2)]))" "(run* [q] (conde [succeed (== q 1)]))" "(run* [?q]
                       (conde
                        (succeed succeed succeed)
                        (succeed fail)
                        (succeed succeed))
                       )" "(run* [q] (fresh [a] (membero a [1 2 3]) (membero q [3 4 5]) (== q a)))" "(run* [q] (membero q [1 2 3])(membero q [3 4 5]))" "(run* [q] (membero q [1 2 3]))" "(run* [q] (== {:a q :b 2} {:a 1 :b 2}))" "(run* [q] (== {:a q :b 2} {:a 1 b 2}))" "(run* [q] (== q {:a 1 :b 2}))" "(run* [q] (type q)(== q 1))" "(type *1)" "(run* [q] (== q 1))" "(run* [q]
                       (conde
                       ((membero q [1 2 3]))
                       ((membero q [2 3 4]))))" "(run* [q]
                       (conde
                       (membero q [1 2 3])
                       (membero q [2 3 4])))" "(run* [q]
                       conde
                       (membero q [1 2 3])
                       (membero q [2 3 4]))" "(run* [q]
                       (membero q [1 2 3])
                       (membero q [2 3 4]))" "(run* [q])" "(run* [?q]
                       (conde
                        (succeed succeed succeed)
                        (succeed fail)
                        (succeed succeed))
                       )" "(run* [?q] (== ?q 1) (== 1 ?q))" "?q" "(run* [?q] (== ?q 1))" "(run* [?q] (== 0 1))" "(run* [?q] (== 1 1))" "(run* [?q])" "(pp)" "(with-dbs [facts fun-people]
                       (run* [q]
                         (conde
                         ((fun q))
                         ((likes q 'Mary)))))" "(in-ns 'logic-tutorial.tut1)" "(pp)" "(+ 1 2)" "pp" "(pprint *1)" "(+ 1 2)" "pp" "(+ 1 2)" "(doc pp)" "(in-ns 'user)" "(doc pp)" "pp" "(+ 1 2)" "pp" "(with-dbs [facts fun-people]
                       (run* [q]
                         (conde
                         ((fun q))
                         ((likes q 'Mary)))))" "(use 'clojure.pprint)" "pp" "(with-dbs [facts fun-people]
                       (run* [q]
                         (conde
                         ((fun q))
                         ((likes q 'Mary)))))" "(with-dbs [facts fun-people]
                       (run* [q]
                         (fun q)
                         (likes q 'Mary)))" "(run* [?q] (== ?q 4))" "(run* [?q] (== 5 4))" "(run* [?q] (== 5 5))" "(with-db genealogy
                       (run* [?q]
                         (grandparent ?q 'Bobby)))" "(def genealogy
                       (-> genealogy
                           (db-fact parent 'George 'John)))" "(with-db genealogy
                       (run* [?q]
                         (son ?q 'John)))" "(def genealogy
                       (db
                        [parent 'John 'Bobby]
                        [male 'Bobby]))" "(with-dbs [men facts] (run* [?q] (fresh [x y] (likes x y) (likes y x) (== ?q [x y]))))" "(with-dbs [men facts] (run* [?q] (fresh [x y] (likes x y) (== ?q [x y]))))" "(with-dbs [men facts] (run* [?q] (fresh [x y] (likes x y) (==?q [x y]))))" "(with-dbs [men facts] (run* [?q] (fresh [x y] (likes x y) (==q [x y]))))" "(with-dbs [men facts] (run* [?q] (likes 'Mary ?q)))" "(def facts (db-fact facts likes 'Mary 'Bob))" "(with-dbs [men facts] (run* [?q] (likes 'Mary ?q)))" "(with-dbs [men facts] (run* [?q] (likes 'Barb ?q)))" "(with-dbs [men facts] (run* [?q] (likes 'Bob ?q)))" "(def facts
                       (-> facts
                           (db-fact likes 'Bob 'Mary)
                           (db-fact likes 'Barb 'Lucy)))" "(db-rel likes x y)" "fun-people" "men" "facts" "(def facts
                       (db
                        [woman 'Lucy]
                        [woman 'Mary]))" "(db-rel woman x)" "(with-dbs [men fun-people]
                       (run* [?q]
                         (man ?q)
                         (fun ?q)))" "(with-dbs [men fun-people]
                       (run* [q]
                         (man q)
                         (fun q)))" "(def fun-people
                       (db
                        [fun 'Bob]))" "(db-rel fun x)" "(with-db men
                       (run 3 [q] (man q)))" "(with-db men
                       (run 2 [q] (man q)))" "(with-db men
                       (run 0 [q] (man q)))" "(with-db men
                       (run 1 [q] (man q)))" "(def men
                       (db
                        [man 'Bob]
                        [man 'Barb]))" "(def men)" "(db-rel man x)" "(in-ns 'logic-tutorial.tut1)" "(load \"logic_tutorial/tut1\")" "(use 'clojure.core.logic)" "(require 'clojure.core.logic)" "(try (c-sqr -11) (catch AssertionError e (str \"erpa: \" e)))" "(try (c-sqr -11) (catch AssertionError e) (str \"erpa: \" e))" "(c-sqr -11)" "(c-sqr 11)" "(pprint *map*)" "*map*" "(map (comp #(reduce + %) rest sort) (partition 4 rolls))" "(repeatedly 6 #(inc (rand-int 20)))" "(repeatedly 6 #(inc (rand-int 6)))" "(repeatedly 6 #(int (rand 6)))" "(repeatedly 6 (int (rand 6)))" "(repeatedly 6 ((int ) rand 6))" "(repeat 6 (rand-int 6))" "(repeat 10 \"3\")" "(- 1 (/ 2 8))" "(/ 8 2)" "(pprint (macroexpand-all '(->> (partition 4 (take 24 (repeatedly #(inc (rand-int 6)))))
     (map sort)
     (map rest)
     (map #(reduce + %)))
                                ))" "(macroexpand-all '(->> (partition 4 (take 24 (repeatedly #(inc (rand-int 6)))))
     (map sort)
     (map rest)
     (map #(reduce + %)))
                                )" "macroexpand-all" "(use 'clojure.walk)" "(use 'clojure-walk)" "(map (comp #(reduce + %) rest sort) (partition 4 rolls))" "(map #(reduce + %) (map (comp rest sort) (partition 4 rolls)))" "(def rolls (take 24 (repeatedly #(inc (rand-int 6)))))" "(->> (partition 4 (take 24 (repeatedly #(inc (rand-int 6))))) (map (comp sort rest #(reduce + %))))" "(->> (partition 4 (take 24 (repeatedly #(inc (rand-int 6))))) (map sort) (map rest) (map #(reduce + %)))" "(->> (partition 4 (take 24 repeatedly #(inc (rand-int 6)))) (map sort) (map rest) (map #(reduce + %)))" "(->> (partition 4 rolls) (map sort) (map rest) (map #(reduce + %)))" "(def rolls (take 24 (repeatedly #(inc (rand-int 6)))))" "(->> (partition 4 rolls) (map sort) (map rest) (map #(reduce + %)))" "(def rolls (take 24 (repeatedly #(inc (rand-int 6)))))" "(->> (partition 4 rolls) (map sort) (map rest) (map #(reduce + %)))" "(->> (partition 4 rolls) (map sort) (map rest) (map #(reduce +)))" "(->> (partition 4 rolls) (map sort) (map rest) (map reduce +))" "(->> (partition 4 rolls) (map sort) (map rest) (reduce +))" "(->> (partition 4 rolls) (map sort) (rest) (reduce +))" "(map sort r2)" "(sort r2)" "(->> r2 (sort) (rest) (reduce +))" "(type r2)" "r2" "(def r2 (vec (partition 4 rolls)))" "(type r2)" "(->> (partition 4 rolls) (sort) (rest) (reduce +))" "rolls" "(def rolls (vec (take 24 (repeatedly #(inc (rand-int 6))))))" "(map sort (vec r2))" "(set! *print-meta* true)" "(map sort (vec r2))" "(vec r2)" "(->> (vec r2) (sort) (rest) (reduce +))" "(->> r2 (sort) (rest) (reduce +))" "(type r2)" "(def r2 (partition 4 rolls))" "(->> (seq (partition 4 rolls)) (sort) (rest) (reduce +))" "(->> (partition 4 rolls) (sort) (rest) (reduce +))" "(map (comp #(reduce + %) rest sort) (partition 4 rolls))" "(->> (partition 4 rolls) (comp rest sort) (reduce +))" "(partition 4 rolls)" "(-> (partition 4 rolls) (sort) (rest) (reduce +))" "(->> (partition 4 rolls) (sort) (rest) (reduce +))" "(->> (partition 4 rolls) sort rest (reduce +))" "(macroexpand-1 *1)" "(macroexpand *1)" "(->> (partition 4 rolls) sort rest #(reduce + %))" "(macroexpand *1)" "(macroexpand-all *1)" "(->> (partition 4 rolls) sort rest #(reduce + %))" "(*1)" "(->> (partition 4 rolls) sort rest #(reduce + %))" "(type *1)" "(->> (partition 4 rolls) sort rest #(reduce + %))" "(type *1)" "(class *1)" "(do *1)" "(eval *1)" "(->> (partition 4 rolls) sort rest #(reduce + %))" "(-> (partition 4 rolls) sort rest #(reduce + %))" "(let [] (->> (partition 4 rolls) sort rest #(reduce + %)))" "(do (->> (partition 4 rolls) sort rest #(reduce + %)))" "(->> (partition 4 rolls) sort rest #(reduce + %))" "(->> (partion 4 rolls) sort rest #(reduce + %))" "(map (comp #(reduce + %) rest sort) (partition 4 rolls))" "(map (comp #(reduce +%) rest sort) (partition 4 rolls))" "rolls" "(map #(reduce + %) (map (comp rest sort) (partition 4 rolls)))" "(map (reduce +) (map (comp rest sort) (partition 4 rolls)))" "(map reduce + (map (comp rest sort) (partition 4 rolls)))" "(apply reduce + (map (comp rest sort) (partition 4 rolls)))" "(reduce + (map (comp rest sort) (partition 4 rolls)))" "(map (comp rest sort) (partition 4 rolls))" "(map sort (partition 4 rolls))" "(reduce + (rest (map sort (partition 4 rolls))))" "(apply rest (map sort (partition 4 rolls)))" "(map sort (partition 4 rolls))" "(apply sort (partition 4 rolls))" "(source 'dm)" "(source dm)" "(defn dm [n] (apply min n))" "(source dm)" "rolls" "(map dm (partition 4 rolls))" "(reduce + (rest (sort '(11 2 3 4))))" "(rest (sort '(11 2 3 4)))" "(sort '(11 2 3 4))" "(sort '(1 2 3 4))" "(apply min-key '(1 3 4))" "(min-key '(1 3 4))" "(Math/abs 1 2 34)" "(#(Math/abs %) '(2 3 4))" "(#(Math/abs '(2 3 4)))" "(doc Math/abs)" "(Math/abs 1 2 34)" "(apply min-key #(Math/abs %) '(22 3 4 5))" "(apply min-key #(Math/abs %) '(2 3 4 5))" "(min-key #(Math/abs %) 2 3 4)" "(min-key (#(Math/abs %) 2 3 4))" "(#(Math/abs %) 2 3 4)" "(#(Math/abs %) 2 3 4))" "(#(Math/abs) 2 3 4))" "(#(Math/abs 2 3 4))" "(doc min-key)" "(min-key '(1 3 4))" "(min-key 1 3 4)" "(filter (= 1 (dm '( 1 2 3 4))) ('1 2 3 4))" "(filter (eq 1 (dm '( 1 2 3 4))) ('1 2 3 4))" "(filter (dm '( 1 2 3 4)) ('1 2 3 4))" "(dm '(1 2 3 4))" "(doc filter)" "(filter dm '( 1 2 3 4))" "(doc index)" "(map dm (partition 4 rolls))" "(defn dm [n] (apply min n))" "(map dm (partition 4 rolls))" "(defn dm [n] (println (apply min n)))" "(apply min '(13 2 3 4))" "(apply min '(1 2 3 4))" "(doc min)" "(min '(1 2 3 4))" "(min (1 2 3 4))" "(map dm (partition 4 rolls))" "(defn dm [n] (println (min n)))" "(map dm (partition 4 rolls))" "(defn dm [n] (min n))" "(defn [n] (min n))" "(partition 4 rolls)" "(class (partition 4 rolls))" "(def rolls (take 24 (repeatedly #(inc (rand-int 6)))))" "(class (partition 4 rolls))" "(partition 4 rolls)" "rolls" "(def rolls (take 24 (repeatedly #(inc (rand-int 6)))))" "(take 24 (repeatedly #(inc (rand-int 6))))" "(take 4 (repeatedly #(inc (rand-int 6))))" "(take 3 (repeatedly #(inc (rand-int 6))))" "(take 30 (repeatedly #(inc (rand-int 6))))" "(take 3 (repeatedly #(inc (rand-int 6))))" "(take 3 (repeatedly #(rand-int 7)))" "(take 3 (repeatedly (rand-int 7)))" "@adum" "(swap! adum #(+ % 13))" "@adum" "(swap! adum #(+ % 13))" "(swap! adum #(+ % %2) -39)" "(swap! adum #(+ % %2) 39)" "(swap! adum #(+ %) 39)" "(def adum (atom 0))" "atum" "'katang" "'niteowl" "(time (for [n (range 1 101)]
  (cond (= 0 (mod n 15)) \"fizzbuzz\"
        (= 0 (mod n 5)) \"buzz\"
        (= 0 (mod n 3)) \"fizz\"
        :else n)))" "(for [n (range 1 101)]
;                     :when (< n 10)]
                 (cond (= 0 (mod n 15)) \"fizzbuzz\"
                       (= 0 (mod n 5)) \"buzz\"
                       (= 0 (mod n 3)) \"fizz\"
                       :else \"\"))" "(for [n (range 1 101)]
#_                     :when (< n 10)]
                 (cond (= 0 (mod n 15)) \"fizzbuzz\"
                       (= 0 (mod n 5)) \"buzz\"
                       (= 0 (mod n 3)) \"fizz\"
                       :else \"\"))" "(for [n (range 1 101)
#_                     :when (< n 10)]
                 (cond (= 0 (mod n 15)) \"fizzbuzz\"
                       (= 0 (mod n 5)) \"buzz\"
                       (= 0 (mod n 3)) \"fizz\"
                       :else \"\"))" "(for [n (range 1 101)
                     :when (< n 10)]
                 (cond (= 0 (mod n 15)) \"fizzbuzz\"
                       (= 0 (mod n 5)) \"buzz\"
                       (= 0 (mod n 3)) \"fizz\"
                       :else \"\"))" "(for [n (range 1 101)
                     :when (< n 10)]
                 (cond (= 0 (mod n 15)) \"fizzbuzz\"
                       (= 0 (mod n 5)) \"buzz\"
                       (= 0 (mod n 3)) \"fizz\"))" "(for [n (range 1 101)
                     :when (< n 10)]
                 (if (= 0 (mod n 3)) \"erpa\" \"zeak\"))" "(for [n (range 1 101)
                     :when (< n 10)]
                 (if (= 0 (mod n 3) \"erpa\" \"zeak\")))" "(for [n (range 1 101)
                     :when (< n 10)]
                 n)" "(for [n (range 1 101)
                     :when (< nn 10)]
                 n)" "(for [n (range 1 101)
                     :let [nn (* n 2)]
                     :when (< nn 10)]
                 n)" "(for [n (range 1 101)
                     :let [nn (* n 2)]
                     :when (< n 10)]
                 n)" "(for [n (range 1 101)

                     :when (< n 10)]
                 n)" "(for [n (range 1 101)
                     #_:let [n (range 1 101)]
                     :when (< n 10)]
                 n)" "(for [x \"katang\"
                     :let [n (range 1 101)]
                     :when (< n 10)]
                 n)" "(for [x \"katang\"
                     :let [n (range 1 101)]
                     :when (<n 10)]
                 n)" "(for [x \"katang\" :let [n (range 1 101)] :when (< n 10)]  n) )" "(for [x \"katang\" :let [n (range 1 101)] :when (< n 10)] (pr n) )" "(for [x \"katang\" :let [n (range 1 101)] :when (< n 10)] (pr n) \"erpa\")" "(for [:let [n (range 1 101)] :when (< n 10)] (pr n) \"erpa\")" "(for [:let [n (range 1 101)] :when (< n 10) (pr n)] \"erpa\")" "(for [z 13 :let [n (range 1 101)] :when (< n 10) (pr n)] \"erpa\")" "(for [z 13 :let [n (range 1 101)] :when (< n 10) (pr n)])" "(for [z 13 :let [n (range 1 101)] :when (< n 10)] (pr n))" "(for [z 13 :let [n (range 1 101)] :when (< n 10)] n)" "(for [z 13 :let [n (range 1 101)] :when (< n 10) n])" "(for [:let [n (range 1 101)] :when (< n 10) n])" "(for [:let n (range 1 101) :when (< n 10) n])" "(for [n (range 1 101) :when (= 0 (mod n 5))] (pr \"buzz\"))" "(for [n (range 1 101) :when (= 0 (mod n 5))] (pr n))" "(10 mod 5)" "(for [n (range 1 101) :when (= 0 (n mod 5))] (pr n))" "(for [n (range 1 101) :when (= 0 (n mod 5))] n)" "(for [n (range 1 101) :when (= 0 (n mod 5))] (n))" "(for [n (range 1 101) :when (n mod 5)] (n))" "(for [n (range 1 101) :when (n % 5)] (n))" "(for [n (range 1 101)] :when (n % 5) (n))" "(for [n rr] :when (n % 5) (n))" "rr" "(def rr(range 1 101))" "(range 1 101)" "'fizzbuzz" "(for [n (range 5)] (println (format \"%d occurred %d times\", n, (fr4 n))))" "(for [n (range 5)] (println (format \"%d: %d\", n, (fr4 n))))" "(for [n (range 5)] (println (format \"%i: %i\", n, (fr4 n))))" "(for [n (range 5)] (println \"%i: %i\", n, (fr4 n)))" "(for [n (range 5) (println \"%i: %i\", n, (fr4 n))])" "(range 5)" "(for [n (range 5)] (map #(% n) fr4))" "(for [n (range 5)] (map #( n)))" "(for [n (range 5)] (map #(fr4 %)))" "(for [n (range 5)] (map #(fr4 n)))" "(fr4 0)" "(fr4 1)" "(:1 fr4)" "(1 fr4)" "(keys fr4)" "fr4" "(def fr4 (apply sorted-map(flatten (seq fr3))))" "fr3" "(apply sorted-map(flatten (seq fr3)))" "(sorted-map(flatten (seq fr3)))" "(sorted-map 1 3 2 1 0 5 4 2 3 5)" "(sorted-map 1 3 2 1 0 5 4 2 3 5))" "(sorted-map(seq fr3))" "(sorted-ma(seq fr3))" "(sorted-map(flatten (seq fr3)))" "(flatten (seq fr3))" "(seq fr3)" "(doc seq)" "(sorted-map fr3)" "(type fr3)" "(flatten fr3)" "(apply sorted-map fr3)" "(vals fr3)" "(keys fr3)" "fr3" "(fr3 4)" "(def fr3 (frequencies (for [n (range 16)] (rand-int 5))))" "(frequencies (for [n (range 16)] (rand-int 5)))" "(for [n (range 16)] (rand-int 5))" "fr" "f4" "(into {} (flatten fr2))" "fr2" "(flatten fr2)" "(flatten fr)" "(into {} (flatten fr))" "(into {} fr)" "(into {} fr2)" "fr2" "(def fr2 (frequencies (for [n (range 16)] (rand-int 5))))" "(frequencies (for [n (range 16)] (rand-int 5)))" "(apply zipmap fr)" "(zipmap (flatten fr))" "(zipmap fr)" "fr" "(def fr (partition 1 (frequencies (for [n (range 16)] (rand-int 5)))))" "fr" "(def fr *1)" "(partition 1 (frequencies (for [n (range 16)] (rand-int 5))))" "(def *1)" "(partition 1 (frequencies (for [n (range 16)] (rand-int 5))))" "(partition 1 (frequencies (for [n (range 16)] (rand-int 3))))" "(partition 2 (frequencies (for [n (range 16)] (rand-int 3))))" "(partition (frequencies (for [n (range 16)] (rand-int 3))))" "(frequencies (for [n (range 16)] (rand-int 3)))" "(for [n (range 16)] (rand-int 3))" "(into {}(frequencies (for [n (range 16)] [(rand-int 3)])))" "(frequencies (for [n (range 16)] [(rand-int 3)]))" "(for [n (range 16)] [(rand-int 3)])" "for [n (range 16)] [(rand-int 3)])" "(into {}(for [n (range 16)] [(rand-int 3)]))" "(flatten (into {}(for [n (range 16)] [(rand-int 3)])))" "(flatten into {}(for [n (range 16)] [(rand-int 3)]))" "(frequencies (flatten (for [n (range 16)] [(rand-int 3)])))" "(frequencies (flatten (for [n (range 6)] [(rand-int 3)])))" "(frequencies (for [n (range 6)] [(rand-int 3)]))" "(for [n (range 6)] [(rand-int 3)])" "(frequencies (for [n (range 6)] ((rand-int 3))))" "(frequencies (for [n (range 6)] [(rand-int 3)]))" "(for [n (range 6)] [(rand-int 3)])" "(flatten *1)" "(into [] *1)" "(for [n (range 6)] [n (rand-int 3)])" "(for [n 6] [n (rand-int 3)])" "(dotimes [n 6] ([n (rand-int 3)]))" "(dotimes [n 6] (prn ([n (rand-int 3)])))" "(dotimes [n 6] (prn ([(rand-int 3)])))" "(doc dotimes)" "(conj () (rand-int 5))" "(doc rand-int)" "(let [ar () er (dotimes [n 16] (rand-int 5))] (println er))" "(let [ar () er (dotimes [n 16] (rand-int 5))] (conj ar er) (println er))" "(let [ar () er (dotimes [n 16] (rand-int 5))] (conj ar er) (println ar))" "(let [ar () er (dotimes [n 16] (rand-int 5))] (conj ar er))" "(let [ar () er (dotimes [n 16] (rand-int 5))])" "(dotimes [n 6] (prn (conj () (rand-int 3))))" "(meta *1)" "aproaches" "(meta aproaches)" "(meta (var aproaches))" "(def ^{:creator \"erpa\"} aproaches (with-meta (list \"insky\" \"pinksy\") {:creator \"me\"}))" "(meta (var aproaches))" "(meta aproaches)" "(def aproaches (with-meta (list \"insky\" \"pinksy\") {:creator \"me\"}))" "(meta (var aproaches))" "(var aproaches)" "(meta *1)" "aproaches" "(meta aproaches)" "(meta approaches)" "(def aproaches (with-meta (list \"insky\" \"pinksy\") (:creator \"me\")))" ";foo" "(foo :nt)" "(foo)" "foo" "#_ foo" "(score perfect-game)" "(def perfect-game (repeat 12 10))" "(def perfect0game (repeat 12 10))" "(score perfect-game)" "(def game (repeat 12 10))" "(def game (repeat 12 10)))" "(score strike-game)" "(score spare-game)" "(score strike-game)" "(score spare-game)" "(score strike-game)" "(score spare-game)" "(def strike-game (concat [10 3 4] (repeat 16 0)))" "(def spare-game (concat [5 5 3] (repeat 17 0)))" "(score game)" "(doc take)" "(score game)" "(defn score [game] (user/score-by-frame game 1))" "(score game)" "(defn score-by-frame [game frame]
                 (letfn [
                         (frame-pins [] (+ (nth game 0) (nth game 1)))]
                 (cond (> frame 10) 0
                       (= 10 (frame-pins))
                       (+ 10 (nth game 2) (score-by-frame (drop 2 game) (inc frame)))
                       :else (+ (frame-pins)
                                (score-by-frame (drop 2 game) (inc frame))))))" "(score game)" "(defn score-by-frame [game frame]
                 (letfn [
                         (frame-pins [] (+ (nth game 0) (nth game 1)))]
                   (= 10 (frame-pins))
                   (+ 10 (nth game 2) (score-by-frame (drop 2 game) (inc frame)))
                 (cond (> frame 10) 0
                       :else (+ (frame-pins)
                                (score-by-frame (drop 2 game) (inc frame))))))" "(defn score-by-frame [game frame]
                 (letfn [
                         (frame-pins [] (+ (nth game 0) (nth game 1)))]
                 (cond (> frame 10) 0
                       :else (+ (frame-pins)
                                (score-by-frame (drop 2 game) (inc frame))))))" "(score game)" "(defn score-by-frame [game frame]
                 (letfn [
                         (frame-pins [] (+ (nth game 0) (nth game 1)))]
                 (cond (> frame 10) 0
                       :else (+ (frame-pins)
                                (score-by-frame (drop 2 game) (inc frame))))))" "(defn score-by-frame [game frame]
                 (letfn [
                         (frame-pins [] (+ (nth game 0) (nth game 1)))])
                 (cond (> frame 10) 0
                       :else (+ (frame-pins)
                                (score-by-frame (drop 2 game) (inc frame)))))" "(defn score-by-frame [game frame]
                 (cond (> frame 10) 0
                       :else (+ (nth game 0)
                                (nth game 1)
                                (score-by-frame (drop 2 game) (inc frame)))))" "(score game)" "(defn score [game] (score-by-frame game 1))" "(defn score [game] (score-by-game game 1))" "(defn score-by-frame [game frame]
                 (cond (> frame 10) 0
                       :else (+ (nth game 0)
                                (nth game 1)
                                (score-by-frame (drop 2 game) (inc frame)))))" "(defn score-by-frame [game frame]
                 (cond (> frame 10) 0
                       else (+ (nth game 0)
                               (nth game 1)
                               (score-by-frame (drop 2 game) (inc frame)))))" "(defn score-by-frame [game frame]
                 (cond (> frame 10) 0
                       else (+ (nth game 0))
                       (+ (nth game 1))
                       (score-by-frame (drop 2 game) (inc frame))))" "(defn score-by-frame [game frame]
                 (cond (> frame 10) 0
                       else (+ nth game 0)
                       (+nth game 1)
                       (score-by-frame (drop 2 game) (inc frame))))" "(score game)" "(def game (concat [5 5 3] (repeat 17 0)))" "(score (concat [5 5 3] (repeat 17 0)))" "(defn score [game] (apply + game))" "(nth (concat [5 5 3] (repeat 17 0)) 2)" "(nth (concat [5 5 3] (repeat 17 0)) 1)" "(nth (concat [5 5 3] (repeat 17 0)) 0)" "(nth (concat [5 5 3] (repeat 17 0) 0
                            ))" "(apply + (concat [5 5 3] (repeat 17 0)))" "(apply + (repeat 20 1))" "(concat [5 5 3] (repeat 17 0))" "(repeat 20 1)" "(repeat 20 0)" "'gutenmorgan" "'niteowl" "(type counter)" "(class counter)" "@counter" "@next-counter" "next-counter" "(reset! atum {:timestamp (java.util.Date.) :counter (next-counter)})" "(defn next-counter [] (dosync (alter counter inc)))" "(def counter (ref 0))" "(reset! atum {:timestamp (java.util.Date.) :counter (next-counter)})" "(defn next-counter [] (dosync (alter counter inc)))" "(defn [] next-counter (dosync (alter counter inc)))" "(def next-counter (dosync (alter counter inc)))" "(reset! atum {:timestamp (java.util.Date.) :counter (next-counter)})" "(def next-counter (dosync alter counter inc))" "(reset! atum {:timestamp (java.util.Date.) :counter (inc @counter)})" "(def counter (atom 0))" "(reset! atum {:timestamp (java.util.Date.) :counter 1})" "(java.util.Date.)" "java.util.Date." "java.util.Date" "(reset! atum {:timestamp java.util.Date. :counter 1})" "(def atum (atom {:date nil :counter 0}))" ";(reset! atum {:timestamp java.util.Date. })" "(def atum (atom {}))" "(dotimes [n 16] (prn (conj () (rand-int 3))))" "(dotimes [n 16] (prn (cons () (rand-int 3))))" "(dotimes [n 16] (prn (into () (rand-int 3))))" "(dotimes [n 16] (prn (list (rand-int 3))))" "(doc seq)" "(dotimes [n 16] (prn (seq (rand-int 3))))" "(doc set)" "(set 1 2 3)" "(doc rand-int)" "(dotimes [n 16] (prn (apply set (rand-int 3))))" "(dotimes [n 16] (prn (set (rand-int 3))))" "(dotimes [n 16] (prn (into #{} (rand-int 3))))" "(dotimes [n 16] (prn (rand-int 3)))" "(dotimes [n 6] (prn (rand-int 3)))" "(dotimes [n 6] (print (rand-int 3)))" "(dotimes [n 6] (rand-int 3))" "(dotimes [6 (rand-int 3)])" "(dotimes 6 (rand-int 3))" ")" "(doc dotimes)" "(repeat 10 (rand-int 3))" "(doc repeat)" "(doc repeatedly)" "(repeatedly 10 (rand-int 3))" "(rand-int 3)" "(doc rand-int)" "(distinct (merge fth thd))" "(distinct fth thd)" "(doc merge-with)" "(merge fth thd)" "(def thd (take-nth 3 (range 100)))" "(def fth (take-nth 5 (range 100)))" "(def 5th (take-nth 5 (range 100)))" "(take-nth 5 (range 100))" "(take-nth 3 (range 100))" "(take-nth 3 [1 2 3 4])" "(take-nth 1 [1 2 3 4])" "(take-nth 2 [1 2 3 4])" "(take-nth [1 2 3 4])" "(doc take-nth)" "(doc takenth)" "(doc range)" "(range (int \\a) (int \\z))" "\\a" "(range \\a \\z)" "(range \"a\" \"z\")" "(range \"z\")" "(apply (juxt (partial - 1) (partial * 2)) [1 2 3])" "(apply (juxt (partial + 1) (partial * 2)) [1 2 3])" "(apply (comp (partial + 1) (partial * 2)) [1 2 3])" "((comp (partial + 1) (partial * 2)) [1 2 3])" "(- 1 1 2 3)" "(- 1 3)" "(- 1 2)" "(- 1 1)" "(apply (partial - 1) [1 2 3])" "((partial - 1) 1)" "( apply blrj [1 2 3])" "( apply blrg [1 2 3])" "(def blrj (juxt (partial - 1) (partial * 2)))" "((juxt (partial + 1) (partial * 2)) [1 2 3])" "( blr [1 2 3])" "(apply blr [1 2 3])" "(def blr (comp (partial - 1) (partial * 2)))" "(apply blr [1 2 3])" "(blr 1)" "(def blr (comp (partial + 1) (partial * 2)))" "(blr 1)" "(apply blr 1)" "(apply blr [1 2 3])" "(blr [1 2 3])" "(def blr (comp (partial +1) (partial *2)))" "((juxt (partial +1) (partial *2)) [1 2 3])" "((comp (partial +1) (partial *2)) [1 2 3])" "(*1)" "*1" "(comp (partial +1) (partial *2) [1 2 3])" "(doc juxt)" "(doc comp)" "(map (comp fn? ifn?) [reduce [] symbol?])" "(map (juxt fn? ifn?) [reduce [] symbol?])" "(map (juxt fn? ifn?) [reduce vec symbol?])" "(map (juxt fn? ifn?) [reduce vector symbol?])" "(map (juxt fn? ifn?) [reduce #{} symbol?])" "(map (juxt fn? ifn?) [reduce {} symbol?])" "(map (juxt fn? ifn?) [reduce {} 123])" "(+ 1)" "(- 2)" "(-2)" "(/)" "(*)" "(+)" "(-)" "(range 10)" "(sum 0 10)" "(sum 0 9)" "(sum (range 10))" "(last (range 10))" "(first (range 10))" "(apply (partial + (swap! @sumatom)) (range 10))" "(apply (partial + 0) (range 10))" "(apply (partial + 0) [1 2 3])" "(apply (partial + 1) [1 2 3])" "(apply (swap! sumatom ((partial + @sumatom))) [0 1 3])" "(apply (swap! sumatom ((partial + @sumatom) [0 1 3])))" "(apply (swap! sumatom (partial + @sumatom) [0 1 3]))" "(apply (swap! sumatom (partial + @sumatom)) [0 1 3])" "(apply (swap! sumatom (partial + @sumatom)) (vec (range 10)))" "(vec (range 10))" "(vec '(range 10))" "(vec '(1 2 3))" "(vec (1 2 3))" "(vector (1 2 3))" "(apply (swap! sumatom (partial + @sumatom) (vector (range 10))))" "(apply (swap! sumatom (partial + @sumatom) (vec (range 10))))" "(apply (swap! sumatom (partial + @sumatom) (range 10)))" "(apply (swap! sumatom (parital + @sumatom) (range 10)))" "(reset! sumatom 0)" "(for [n (range 10)] (swap! sumatom (partial + @sumatom) n) )" "(for [n (range 10)] (swap! sumatom (partial + @sumatom) n) n )" "(for [n (range 10)] (swap! sumatom (partial + @sumatom) n) )" "(reset! sumatom 0)" "(for [n (range 10)] (swap! sumatom (partial + @sumatom) n) )" "(for [n (range 10) :let [sumy (swap! sumatom (partial + @sumatom) n)]] @sumatom)" "(reset! sumatom 0)" "@sumatom" "(for [n (range 10) :let [sumy (swap! sumatom (partial + @sumatom) n)]] \"arp\")" "(reset! sumatom 0)" "@sumatom" "(for [n (range 10) :let [sumy (swap! sumatom (partial + @sumatom) n)]] \"arp\")" "@sumatom" "(for [n (range 10) :let [sumy (swap! sumatom (partial + @sumatom) n)]] (last sumy))" "(for [n (range 10) :let [sumy (swap! sumatom (partial + @sumatom) n)]] sumy)" "(swap! sumatom (partial + @sumatom))" "(doc swap!)" "(swap! sumatom (+ 1 @sumatom))" "(for [n (range 10) :let [sumy (swap! sumatom (+ n @sumatom))]] sumy)" "(Long/toString (swap! adom inc) 36)" "(for [n (range 10) :let [sumy (+ n 1)]] sumy)" "(for [n (range 10) asum 0 :let [sumy (+ n 1)]] sumy)" "(for [n (range 10) :let [sumy (+ n 1)]] sumy)" "(for [n (range 10) :let [sumy (+ n 0)]] sumy)" "(for [n (range 10) :let [sumy (+ n sumy)]] sumy)" "(for [n (range 10) :let [sumy (+ n sumy)]])" "(for [n (range 10) :let [sumy (+ n 0)]])" "(for [n (range 10) :let [sumy (partial + 1)]])" "(for [n (range 10)] [(alter sumatom (+ n))])" "(def sumatom (atom 0))" "sumatom" "(map #(partial (range 10))
                    )" "(for [sumatom 0 n (range 10)] [(+ n sumatom)])" "(for [sumatom (range 3) n (range 10)] [(+ n sumatom)])" "(for [sumatom (range 3) n (range 10)] [n sumatom])" "(for [sumatom (range 3) n (range 10)] (+ n sumatom))" "(for [sumatom (range 3) n (range 10)] + n sumatom)" "(for [sumatom 0 n (range 10)] + n sumatom)" "(for [sumatom 0 n (range 10)] (+ n sumatom))" "(for [n (range 10) sumatom 0] (+ n sumatom))" "(for [n (range 10) sumatom 0] [(+ n sumatom)])" "(into {} *1)" "(for [n [1 2 3] let [:a :b :c]] {let n})" "(for [n [1 2 3] let [:a :b :c]] (flatten {let n}))" "(for [n [1 2 3] let [:a :b :c]] {let n})" "(for [n [1 2 3] let [:a :b :c]] (into {} let n))" "(for [n (range 10) sumatom 0] (+ n sumatom))" "(for [n (range 10)] n)" ";(map #(partial (range 10)" "(range 10)" "@result" "(def sup (.start (Thread. (deliver result (sum 1 1e7)))))" "(def result (promise))" "(def sup (.start (Thread. (deliver result (sum 1 1e7)))))" "(source future)" "(time @*1)" "(time (delay (sum 0 1e7)))" "(time (sum 0 1e7))" "(time (+ (sum (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2))))" "(time (sup3))" "(defn sup3 [] 
                 (let [x (future (sum (/ 1e7 2) 1e7))
                       y (future (sum 0 (/ 1e7 2)))]
                   (fmt (+ @x @y))))" ";(time (sup3))" "(time (fmt (+ @(future (sum (/ 1e7 2) 1e7)) @(future (sum 0 (/ 1e7 2))))))" "(def fmt (partial format \"%,10.0f\"))" "(time (fmt (+ @(future (sum (/ 1e7 2) 1e7)) @(future (sum 0 (/ 1e7 2))))))" "(def fmt (partial format \"%,10f\"))" "(time (+ @(future (sum (/ 1e7 2) 1e7)) @(future (sum 0 (/ 1e7 2)))))" "(+ @(future (sum (/ 1e7 2) 1e7)) @(future (sum 0 (/ 1e7 2))))" "(time (sup3))" "(defn sup3 [] 
                 (let [x (future (sum (/ 1e7 2) 1e7))
                       y (future (sum 0 (/ 1e7 2)))]
                   (format \"%,10.1f\" (+ @x @y))))" "(time (sup3))" "(defn sup3 [] 
                 (let [x (future (sum (/ 1e7 2) 1e7))
                       y (future (sum 0 (/ 1e7 2)))]
                   (+ @x @y)))" "(defn sup3 [] 
                 (let [x (future (sum (/ 1e7 2) 1e7))
                       y (future (sum 0 (/ 1e7 2)))]
                   (+ x y)))" ";(defn foon4 [] (sum 0 (/ 1e7 2)))" ";(defn foon5 [] (sum (/ 1e7 2) 1e7))" "(format \"e = $%,6d\", (* 1000 (count @stuff)))" "(format \"e = $%,6d\", (* 1e7 (count @stuff)))" "(format \"e = $%,6d\", (* 10 (count @stuff)))" "(format \"e = $%,6d\", (count @stuff))" "(format \"e = $%,10d\", (count @stuff))" "(format \"e = %,$10d\", (count @stuff))" "(format \"e = %$,10d\", (count @stuff))" "(format \"e = %,10d\", (count @stuff))" "(format \"e = %10,d\", (count @stuff))" "(format \"e = %10d\", (count @stuff))" "(format \"e = %+10d\", (count @stuff))" "(format \"e = %+10.4d\", (count @stuff))" "(format \"e = %+10.4f\", (count @stuff))" "(javadoc java.util.Formatter)" "(count @stuff)" "(count stuff)" "stuff" "(def stuff (future (slurp \"http://www.mozilla.org/about/manifesto.en.html\")))" "(+ @(future (sum (/ 1e7 2) 1e7)) @(future (sum 0 (/ 1e7 2))))" "(+ 1 2)" "(+ (future (sum (/ 1e7 2) 1e7)) (future (sum 0 (/ 1e7 2))))" "@*1" "(future (sum 0 (/ 1e7 2)))" "@*1" "(future (sum (/ 1e7 2) 1e7))" "@foon32" "(def foon32 (future (foon4) (foon5)) )" "(def foon32 ((future (foon4)) (future (foon5))))" "(def foon32 (future (foon4)) (future (foon5)))" "(def foon32 (+ (future (foon4)) (future (foon5))))" "(time (+ (future (foon4) (foon5))))" "(time (+ @(future (foon4)) @(future (foon5))))" "(time (+ (foon4) (foon5)))" "(time (+ @(future (foon4) (foon5))))" "(time (+ @(future (foon4)) @(future (foon5))))" "(time (+ (@(future (foon4))) (@(future (foon5)))))" "(time @(+ (future (foon4)) (future (foon5)) ))" "(time (+ (future (foon4)) (future (foon5))))" "(time (+ @(future (foon4)) @(future (foon5))))" "(time (+ (@(future (foon4))) (@(future (foon5)))))" "(time (+ (foon4) (foon5)))" "(time (+ @(future (foon4) (foon5))))" "(+ @(future (foon4) (foon5)))" "(+ @foon4 @foon5)" "(+ @foo4 @foo5)" "(future foon5)" "(future foon4)" "(foon5)" "(foon4)" "(defn foon5 [] (sum (/ 1e7 2) 1e7))" "(defn foon5 [] sum (/ 1e7 2) 1e7)" "(defn foon4 [] (sum 0 (/ 1e7 2)))" "(defn foon4 (sum 0 (/ 1e7 2)))" "foon5" "(def foon5 (future (sum (/ 1e7 2) 1e7)))" "foon5" "foo5" "(def foon5 (future (sum (/ 1e7 2) 1e7)))" "(time (+ @foon5 @foon6))" "(time (+ @foon3 @foon4))" "(def foon5 (future (sum (/ 1e7 2) 1e7)))" "(def foon6 (future (sum 0 (/ 1e7 2))))" "(time (+ @foon3 @foon4))" "(def foon3 (future (sum (/ 1e7 2) 1e7)))" "(def foon4 (future (sum 0 (/ 1e7 2))))" "(time (+ @foon3 @foon4))" "foon4" "foon3" "(time (+ @foon3 @foon4))" "(def foon4 (future (sum 0 (/ 1e7 2))))" "(def foon3 (future (sum (/ 1e7 2) 1e7)))" "(time (+ @foon3 @foon4))" "(time (+ @(foon3) @(foon4)))" "(time (+ @(foon) @(foon2)))" "(def foon3 (future (sum (/ 1e7 2) 1e7)))" "(def foon4 (future (sum 0 (/ 1e7 2))))" "(+ foon3 foon4)" "(def foon4 (sum 0 (/ 1e7 2)))" "(defn foon4 (sum 0 (/ 1e7 2)))" "(def foon3 (sum (/ 1e7 2) 1e7))" "(time (+ @(foon) @(foon2)))" "(defn sum [start end] (reduce + (range start end)))" "(time (+ @(foon) @(foon2)))" "(+ @(foon) @(foon2))" "(defn foon [] (future (sum (/ 1e7 2) 1e7)))" "sum" "(defn foon2 [] (future (sum 0 (/ 1e7 2))))" "[@(foon) @(foon2)]" "(defn foon2 [] (let [x 13 y 10] (future (* y x))))" "(defn foon [] (let [x 13 y 11] (future (+ y x))))" "[@(foon) @(foon2)]" "@(foon2)" "@(foon)" "@*1" "[(foon) (foon2)]" "(defn foon2 [] (let [x 13 y 11] (future (* y x))))" "@(foon)" "(defn foon [] (let [x 13 y 11] (future (+ y x))))" "foon" "foo" "@(foon)" "(defn foon [] (let [x 13 y 11] [(future (+ 2 x)) (future (-3 y))]))" "@(foon)" "(shutdown-agents)" "@*1" "(foon)" "@(foon)" "(defn foon [] (let [x 13 y 11] [(future (+ 2 x)) (future (-3 y))]))" "@(foon)" "(defn foon [] (let [x 13 y 11] [(future (+ 2 x))(future (-3 y))]))" "@(foon)" "(defn foon [] (let [x 13 y 11] (future (+ 2 x))(future (-3 y))))" "@(foon)" "(foon)" "foon" "(foon)" "(defn foon [] (let [x 13] (future (+ 2 x))))" "(foon)" "(defn foon [] (let [x 13] (+ 2 x)))" "(doc future)" "(def sum3 (+ (future (fn [] (sum (/ 1e7 2) 1e7))) (future (fn [] (sum 0 (/ 1e7 2))))))" "(def sum3 (+ (.start (Thread. (fn [] (sum (/ 1e7 2) 1e7)))) (.start (Thread. (fn [] (sum 0 (/ 1e7 2)))))))" "(def sum3 (+ (.start (Thread. (sum (/ 1e7 2) 1e7))) (.start (Thread. (sum 0 (/ 1e7 2))))))" "(def sum3 (+ (.start (Thread. (sum (/ 1e7 2) 1e7))) (.start (Thread. (future (sum 0 (/ 1e7 2)))))))" "(def sum3 (+ (.start (Tread. (sum (/ 1e7 2) 1e7))) (.start (Thread. (sum 0 (/ 1e7 2))))))" "(def sum3 (+ (.start (Thread. (future(sum (/ 1e7 2) 1e7)))) (.start (Thread. (future (sum 0 (/ 1e7 2)))))))" "(def sum3 (+ (.start (Thread. (sum (/ 1e7 2) 1e7))) (.start (Thread. (future (sum 0 (/ 1e7 2)))))))" "(def sum3 (+ (.start (Thread. (sum (/ 1e7 2) 1e7))) (.start (Thread. (sum 0 (/ 1e7 2))))))" "(def sum3 (+ (.start (Tread. (sum (/ 1e7 2) 1e7))) (.start (Thread. (sum 0 (/ 1e7 2))))))" "(def sum3 (+ (.start (sum (/ 1e7 2) 1e7)) (.start (sum 0 (/ 1e7 2)))))" "(def sum3 (+ (future (sum (/ 1e7 2) 1e7)) (.start (sum 0 (/ 1e7 2)))))" "(def sum3 (+ (future (sum (/ 1e7 2) 1e7)) (future (sum 0 (/ 1e7 2)))))" "sum3" "(def sum3 (future (sum (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2))))" "(def sum3 ((future (sum (/ 1e7 2) 1e7)) (future (sum 0 (/ 1e7 2)))))" "(def sum3 (future (sum (/ 1e7 2) 1e7)) (future (sum 0 (/ 1e7 2))))" "(def sum3 (+ (future (sum (/ 1e7 2) 1e7)) (future (sum 0 (/ 1e7 2)))))" "(def sum3 (time (+ (future (sum (/ 1e7 2) 1e7)) (future (sum 0 (/ 1e7 2))))))" "(def sum3 (time(+ (sum (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2)))))" "(def sum3 (future (time(+ (sum (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2))))))" "(defn sum [start end] (reduce + (range start end)))" "(doc time)" "(def sum3 (future (time(+ (sum (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2))))))" "sum3" "(def sum3 (future (+ (sum (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2)))))" "(def sum3 (+ (sum (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2))))" "(def sum3 (+ (/ 1e7 2) 1e7) (sum 0 (/ 1e7 2)))" "(def sum3 (+ (sum1) (sum2)))" "sum2" "sum1" "(def sum2 (sum (/ 1e7 2) 1e7))" "(def sum1 (sum 0 (/ 1e7 2)))" "result" "(def sup (.start (Thread. (deliver result (sum 1 1e7)))))" "(def result (promise))" "@result" "result" "(def sup (future (Thread/sleep 500) (deliver result (sum 1 1e7))))" "result" "(def sup (future (deliver result (sum 1 1e7))))" "sum" "(defn sum [start end] (time (reduce + (range start end))))" "sum" "(def sup (future (deliver result (sum 1 1e7))))" "(sum)" "result" "sum" "result" "(def sum (future (deliver result (sum 1 1e7))))" "(def result (promise))" "@box" "(deliver box {:erpas :Derpas})" "box" "(type box)" "(def box (promise))" "@suu" "(time suu)" "(def suu (delay (sum 0 1e7)))" "(defn sum [start end] (time (reduce + (range start end))))" "@suu" "(time suu)" "(def suu (delay (sum 0 1e7)))" "suu" "@suu" "suu" "(def suu (delay (sum 0 1e7)))" "(defn sum [start end] (reduce + (range start end)))" "'niters" "'just 'so" "'yoderpa" "(map meta (TreeNode/getBasis))" "(javadoc TreeNode)" "(map meta (TreeNode/getBasis))" "(meta (TreeNode/getBasis))" "(TreeNode/getBasis)" "(fac 10)" "(fac 4)" "(fac 3)" "(defn fac [n] (if (= n 1) 1 (* n (fac (dec n)))))" "(defn fac [n] if (= n 1) 1 (* n (fac (dec n))))" "(xseq sample-tree)" "(defn xseq [t]
                 (when t
                   (concat (xseq (:l t)) [(:val t)] (xseq (:r t)))))" "(xseq sample-tree)" "sample-tree" "(def sample-tree (reduce xconj nil [3 5 2 4 6]))" "(defn xconj [t v]
  (cond
   (nil? t)       (TreeNode. v nil nil)
   (< v (:val t)) (TreeNode. (:val t) (xconj (:l t) v) (:r t))
   :else          (TreeNode. (:val t) (:l t) (xconj (:r t) v))))" "(defn xconj [t v]
  (cond
   (nil? t)       (TreeNpde. v nil nil)
   (< v (:val t)) (TreeNode. (:val t) (xconj (:l t) v) (:r t))
   :else          (TreeNode. (:val t) (:l t) (xconj (:r t) v))))" "(source xconj)" "sample-tree" "(def sample-tree (reduce xconj nil [3 5 2 4 6]))" "(->TreeNode 5 nil nil)" "(TreeNode 5 nil nil)" "(TreeNode. 5 nil nil)" "(TreeNode 23 nil nil)" "TreeNode" "foot" "tree1" "(xseq tree1)" "(def tree1 (xconj tree1 13))" "(defn xconj [t v] (cond (nil? t) {:val v :L nil :R nil}
                                       (< v (:val t)) {:val (:val t),
                                                       :L (xconj (:L t) v),
                                                       :R (:R t)}
                                       :else {:val (:val t)
                                                       :L (:L t)
                                                       :R (xconj (:R t) v)}))" "(defn xconj [t v] (cond (nil? t) {:val v :L nil :R nil}
                                       (< v (:val t)) {:val (:val t),
                                                       :L (xconj (:L t) v),
                                                       :R (:R t)}
                                       :else {(:val t)
                                                       :L (:L t)
                                                       :R (xconj (:R t) v)}))" "(defn xconj [t v] (cond (nil? t) {:val v :L nil :R nil}
                                       (< v (:val t)) {:val (:val t),
                                                       :L (xconj (:L t) v),
                                                       :R (:R t)
                                       :else (:val t)
                                                       :L (:L t)
                                                       :R (xconj (:R t) v)}))" "(xseq tree1)" "(defn xseq [t]
                 (when t
                   (concat (xseq (:L t)) [(:val t)] (xseq (:R t)))))" "tree1" "(def tree1 (xconj tree1 2))" "tree1" "(def tree1 (xconj tree1 3))" "tree1" "(def tree1 (xconj nil 5))" "(defn xconj [t v] (cond (nil? t) {:val v :L nil :R nil}
                                       (< v (:val t)) {:val (:val t),
                                                       :L (xconj (:L t) v),
                                                       :R (:R t)}))" "(type *1)" "(xconj nil 5)" "(type *1)" "(defn xconj [t v] (cond (nil? t) (hash-map :val v :L nil :R nil)))" "(type (hash-map nil nil))" "(type (hash-map nil))" "(type hash-map nil)" "(type hashmap nil)" "(type {})" "(type ())" "(type *1)" "(xconj nil 5)" "(defn xconj [t v] (cond (nil? t) {:val v :L nil :R nil}))" "(defn xconj [t v] cond (nil? t) {:val v :L nil :R nil})" "foot" "@x54" "(erp)" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc) (reset! x54 {(ensure x5) (ensure x4)})))" "(erp)" "@x54" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)) (reset! x54 {(ensure x5) (ensure x4)}))" "@x54" "(val (first @x54))" "(key (first @x54))" "(keys @x54)" "(type (@x54 1))" "(type (@x54 0))" "(type @x54)" "(type x54)" "(type (val x54))" "(type (val @x54))" "(type (key x54))" "(type (key @x54))" "@x54" "(erp)" "@x54" "(dosync (ref-set x5b (java.util.Date.)))" "(type java.util.Date)" "(type java.util.Date.)" "(dosync (alter x5b (java.util.Date.)))" "x5b" "(def x5b (ref (java.util.Date.)))" "(def x5b (ref (java.util.date)))" "(erp)" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)) (reset! x54 {@x5 @x4}))" "(reset! x54 {@x5 @x4})" "@x54" "(erp)" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)))" "(erp)" "@x54" "erp" "@x54" "erp" "@x54" "x54" "(def x54 (atom {@x5 @x4}))" "(def erp (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)))" "@x5" "@x4" "x45" "(dosync (ref-set x5 (java.util.Date.)) (alter x4 inc))" "(doc doseq)" "(doseq (ref-set x5 (java.util.Date.)) (alter x4 inc))" "x45" "(def x45 {@x5 @x4})" "(def x5 (ref (java.util.Date.)))" "(def x4 (ref 23))" "(doc alter)" "x3" "(inc (:a @x3))" "(swap! x3 (inc (:a @x3)))" "(:a x3)" "(:a @x3)" "(swap! x3 (inc (:a x3)))" "(def x3 (atom {:a 23}))" ";(reset! x2 ({(java.util.Date.) 13}))" "@x2" "(def x2 (atom{(java.util.Date.) 13}))" "@@x2" "@x2" "(reset! x2 (atom{(java.util.Date.) 13}))" "x2" "(doc reset!)" "@x2" "x2" "(first x2)" "(val @x2)" "(first @x2)" "@x2" "(val (first @x2))" "(reset! x2 (atom{(java.util.Date.) 13}))" "(val (first @x2))" "@x2" "(swap! x2 {(java.util.Date.) (inc (val (first @x2)))})" "(val (first @x2))" "(val @x2)" "(doc val)" "@x2" "(def x2 (atom{(java.util.Date.) 13}))" "(def x2 (atom{java.util.Date. 13}))" "(def x2 {java.util.Date. 13})" "(java.util.Date.)" "(Date.)" "Date." "(swap! x identity)" "(swap! x identity?)" "(realized? x)" "@x" "x" "(def x (atom 13))" "x" "(doc swap!)" "(doc reset!)" "(realized? kat)" "kat" "(realized? kat)" "(def kat (map inc [1 2 3]))" "(def kat (map #(inc) [1 2 3]))" "(realized? foot)" "(doc realized?)" "(realized? box)" "@box" "(realized? box)" "(deliver box :turtles-all-the-way-down-here)" "(realized? box)" "(def box (promise))" "(realized? later)" "later" "(realized? later)" "(realized? box)" "(delivered? box)" "(doc realized?)" "(doc deliver)" "(doc promise)" "@box" "(deliver box :turtles-all-the-way-down)" "@box" "box" "(def box (promise))" "(dotimes [i 5] (future (prn i)))" "@later" "later" "(meta #'later)" "#'later" "@(*5)" "@(type *4)" "(type *3)" "@later" "(type *1)" "later" "(type later)" "(def later (delay (prn \"Adding\") (+ 1 2)))" "(<= 60 88)" "(if-not true 42 (dbg(/ 1 3)))" "(if-not true 42 (dbg(/ 1 0)))" "(if true 42 (dbg(/ 1 0)))" "(barney)" "()" ")" "(if true 42 (/ 1 0))" "(type true)" "(if true 42 1/0)" "(/ 1 0)" "(pprint (keys (ns-interns *ns*)))" "(keys (ns-interns *ns*))" "(ns-interns *ns*)" "(defrecord TreeNode [val l r])" "(map #(re-seq #\"(joy)\" (str %)) ee)" "(map #(re-seq #\"([joy])\" (str %)) ee)" "(map #(re-seq #\"joy\" (str %)) ee)" "(map #(re-seq #(\"joy\") (str %)) ee)" "(map #(re-seq #\"joy\" (str %)) ee)" "(map #(re-matches #\"joy\" (str %)) ee)" "(map #(re-find #\"joy\" (str %)) ee)" "(map #(re-mather #\"joy\" (str %)) ee)" "(map #(re-groups (re-matcher #\"joy\" (str %))) ee)" "(map #((re-groups re-matcher #\"joy\" (str %))) ee)" "(map #((re-groups re-mather #\"joy\" (str %))) ee)" "(map #(re-mather #\"joy\" (str %)) ee)" "(map #(re-find #\"joy\" (str %)) ee)" "(map #(re-find #\"joy\" %) ee)" "(map #(re-find #\"joy\") ee)" "(type ee)" "(typeee)" "ee" "(doc ns-interns)" "(ns-interns *ns*)" "(count (ns-interns *ns*))" "(*ns* interns)" "(interns *ns*)" ";(def (TreeNode. 5 nil nil)" "(doc TreeNode.)" "(doc TreeNode)" "(type TreeNode.)" "(type TreeNode)" "(TreeNode. 5 nil nil)" "(TreeNode 5 nil nil)" "(defrecord TreeNode [val l r])" "(get2 (beget {:sub 0} {:super 1}) :super)" "(defn get2 [m k]
  (when m
    (if-let [[_ v] (find m k)]
      v
      (recur (::prototype m) k))))" "(get (beget {:sub 0} {:super 1}) :super)" "(find {:erpa 1} :erpa)" "(get {:erpa 1} :erpa)" "(assoc {:sub 0} ::erpa {:super 1})" "(assoc {:sub 0} {::erpa {:super 1}})" "(assoc {:sub 0} {:super 1})" "(doc assoc)" "(beget {:sub 0} {:super 1} )" "(defn beget [o p] (assoc o ::prototype p))" "(ee 'clojure.set)" "(sort ee)" "(def ee (set (map ns-name allns)))" "(sort ee)" "(contains? ee 'clojure)" "(contains? ee 'clojure.set)" "(ee 'clojure.set)" "(ee 'clojure)" "(count ee)" "(def ee (set (map ns-name bb)))" "(dd :c)" "(cc :c)" "(def dd(set cc))" "(def dd(set cc)" "(set cc)" "(hash-map cc)" "(into {} cc)" "(keys cc)" "(get cc ':a)" "cc" "(get cc :a)" "(cc :a)" "(def cc [:a :b :c])" "(find cc 'clojure.set)" "(doc get)" "(type 'clojure.set)" "(type (first cc))" "(type first cc)" "(get cc clojure.set)" "(get cc 'clojure.set)" "(get cc 'clojure)" "cc" "(def cc (into [] (map ns-name bb)))" "(into [] (map ns-name bb))" "(into [] (ns-name bb))" "(vec (ns-name bb))" "bb" "(type(ns-name *ns*))" "(map ns-name bb)" "(ns-name *ns*)" "(type *ns*)" "(count (ns-map (nth bb 4)))" "(count (ns-map (nth bb 2)))" "(count (ns-map (second bb)))" "(count (ns-map (first bb)))" "(count (ns-map first bb))" "(map first bb)" "(first bb)" "'bb" "'bbb" "#'*ns*" "(count bb)" "(get bb 'clojure)" "(bb 'clojure)" "(def bb *2)" "(count(into [](take 5 allns)))" "(into [](take 5 allns))" "(into {}(take 5 allns))" "(take 5 allns)" "(apply type (take 1 allns))" "(type (take 1 allns))" "(get allns 'clojure.test)" "(get allns \"clojure\")" "(get allns 'clojure)" "(allns 'clojure)" "(take 5 allns)" "(count allns)" "(class allns)" "(type allns)" "(count (allns))" "(def allns (all-ns))" "(count (partition 5 allns))" "(count (partition 1 allns))" "(count (parition 1 allns))" "(count (take 5 allns))" "(count (take 1 allns))" "(take 1 allns)" "(take 5 allns)" "'" "(into {} allns)" "(into {} (all-ns))" "(into {} (ns-all))" "(allns 'clojure)" "(count allns)" "(def allns (vector(all-ns)))" "(doc all-ns)" "((all-ns) 'clojure)" "(contains? (all-ns) 'clojure)" "(count(all-ns))" "(all-ns)" "(find-ns *ns*)" "(find-ns 'fooz)" "(find-ns 'String)" "(doc find-ns)" "((ns-map *ns*) 'fooz)" "((ns-map 'clojure.core) 'fooz)" "((ns-map 'clojure.core) 'String)" "(doc ns-map)" "(count (ns-interns *ns*))" "(def fooz \"baz\")" "(count (ns-interns *ns*))" "(count (ns-refers 'user))" "(count (ns-refers 'new-stuf.core-test))" "(count (ns-refers 'new-stuf.core))" "(count (ns-refers 'clojure.core))" "(count (ns-interns *ns*))" "(count (ns-imports *ns*))" "(count (ns-refers *ns*))" "(count (ns-refers *ns*)
                      )" "(ns-map 'clojure.core)" "(ns-map 'new-stuf.core)" "(lu3 \"a1\")" "(lue \"a1\")" "(defn lu3 [pos] (let [[f r] (map int pos)] (prn [f r])))" "(defn lu3 [pos] (let [[f r]] (map int pos) (prn [f r])))" "(map int \"a1\")" "(joy.chess/initial-board)" "((joy.chess/initial-board) 56)" "(joy.chess/initial-board 56)" "joy.chess/initial-board" "initial-board" "(foor2 \\1)" "(defn foor2 [x] (->> (int \\0) (- (int x))))" "(foor \\1)" "(defn foor [x] (->> (int \\0) (- (int x)) (- 8) (* 8)))" "(- -1 8)" "(- 48 49)" "(int \\1)" "(take 8 (range (int \\a) (+ 8 (int \\a))))" "(take 2 (range (int \\a) (+ 8 (int \\a))))" "(take 2 (range (int \\a) ((+ 8 int \\a))))" "(take 2 (range (int \\a) 8))" "(take 2 (range (int \\a)))" "(take 2 (range \\a))" "(int \\0)" "(int \\a)" "(into {} (vec '([:a 1] [:a 3])))" "(vec '([:a 1] [:a 3]))" " (seq '([:a 1] [:a 3]))" " (into {} '([:a 1] [:a 3]))" " (first '([:a 1] [:a 3]))" " (first ([:a 1] [:a 3]))" " (into {} ([:a 1] [:a 3]))" " (seq ([:a 1] [:a 3]))" "(vec (seq ([:a 1] [:a 3])))" "(vec ([:a 1] [:a 3]))" "(vec {:a 1 :b 2})" "(vector 1 23 [3 5] 16)" "(vector 1 23 [3 5])" "(vec '(1 2 3))" "(vec [1 2] [3 4])" "(nthrest [1 2 3] 0)" "(nth [1 2 3] 0)" "(nthnext [1 2 3] 0)" ";is there a way to get ([:a 1] [:a 3] [:b 1] [:b 3]) into [{:a 1} {:a 3} {:b1} {:b3}] ?" "(apply array-map boo)" "(apply array-map [:a 1 :b 2])" "(hash-map '(:a 1 :b 2))" "(apply hash-map boo)" "boo" "(into {} boo)" "(def boo (for [x [:a :b], y (range 5) :when (odd? y)] [x y]))" "(into {} (for [x [:a :b], y (range 5) :when (odd? y)] [x y]))" "(for [x [:a :b], y (range 5) :when (odd? y)] [x y])" "(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))" "(doc for)" "(for [x [:a :b], y (range 5) :when (odd? y)] [x y])" "(for [x [:a :b], y (range 5) :when (odd? y)])" "'yerpado" "valor" "`(foo ~@[1 2 3])" "`(foo ~[1 2 3])" "(foob 1)" "(type #'foob)" "(type foob)" "(type 'foob)" "(source foob)" "(source 'foob)" "(foob 2)" "(pprint (macroexpand '(or a b c d)))" "(macroexpand '(hello \"yew\"))" "(pprint (macroexpand '(hello \"yew\")))" "(meta #'hello)" "(defmacro hello [x] (str \"hello, \" x))" "(pprint (macroexpand '(hello \"yew\")))" "(macroexpand '(ignore (+ 1 2)))" "(macroexpand '(ignore (dbg (+ 1 2))))" "(macroexpand '(rev str \"hi\" (+ 1 2)))" "(macroexpand (rev str \"hi\" (+ 1 2)))" "(rev str \"hi\" (+ 1 2))" "(defmacro rev [fn & args] (cons fn (reverse args)))" "(defmacro rev [fn & args] (cons fun (reverse args)))" "(ignore (dbg (+ 1 2)))" "(macroexpand (ignore (dbg (+ 1 2))))" "(macroexpand (ignore (+ 1 2)))" "(ignore (+ 1 2))" "(defmacro ignore [expr] nil)" "(doc realized?)" "(reductions + 0 [1 2 3])" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head  \" - \" tail)) )" "(doc reductions)" "(take 10 fib)" "(fib)" "(doc apply)" "(meta *2)" "*3" "*1" "(apply hash-map [:a 1 :b 2])" "(set! *print-meta* true)" "(apply hash-map [:a 1 :b 2])" "(apply array-map [:a 1 :b 2])" "(interleave [:a 1 :b 2])" "(zipmap [:a 1 :b 2])" "(hash-map '(:a 1 :b 2))" "(hash-map (:a 1 :b 2))" "(hash-map :a 1 :b 2)" "(doc hash-map)" "(hash-map [:a 1 :b 2])" "(doc concat)" "(doc map-indexed)" "(map-indexed (fn [index element] (str index \". \" element)) [\"erlang\" \"ruby\" \"haskell\"])" "(take 3 (repeatedly ((* 10 (rand)))))" "(take 3 (repeatedly (* 10 (rand))))" "(* 10 (rand))" "(Math/floor 10.23)" "Math/floor 10.23" "(* 10 (rand))" "(rand)" "(take 3 (* 10 (repeatedly rand )))" "(take 3 (repeatedly rand ))" "(take 3 (repeatedly (* (rand) 10.0)))" "(take 3 (repeatedly (* (rand) 10)))" "(take 3 (repeatedly (* rand 10)))" "(take 5 (iterate (fn [x] (str x \"o\")) \"y\"))" "(take 10 (iterate (fn [x] (if (odd? x) (+ 1 x) (/ x 2))) 10))" "(take 10 (iterate inc 0))" "(if false \"fooey\")" "(if false \"fooey\" \"barney\")" "(if true \"fooey\" \"barney\")" "(if true \"fooey\")" "(type (drop 1 fool))" "(type fool)" "(def zz 23)" "(barney)" "clojure.tools.namespace.find" "(require '[clojure.tools.namespace] :verbose)" "(require '[org.clojure/tools.namespace] :verbose)" "(require '[org.clojure/tool.namespace] :verbose)" "(require '(org.clojure/tool.namespace))" "(alembic.still/load-project)" "(require '[alembic.still] :verbose)" "(def a 1)" "a" "(barney)" "(apply list (barney 23))" "(apply map vector [[1 2 3]])" "(apply map vector [1 2 3])" "(map vector [1 2 3])" "(vector 1 2 3 [4 5])" "(vector 1 2 3)" "(vector [1 2 3 [4 5]])" "(vector [1 2 3])" "(seq (concat [1 2 3] {:a 13 :b 11}))" "(concat [1 2 3] {:a 13 :b 11})" "(concat [1 2 3] [4 5 6])" "(sort > [3 5 4])" "(sort < [3 5 4])" "(sort [3 5 4])" "((seq (seq [1 2 3]) [4 5 6]))" "(seq [1 2 3] [4 5 6])" "(map *1 [3 4 10])" "(comp sum count avg)" "(map (comp sum count avg) [3 4 10])" "(map #(% [3 4 10] [2 2 2]) [sum count avg] )" "(map #(% [3 4 10]) [sum count avg] )" "(map #(% numbers) [sum count avg] [3 4 10])" "(stats [3 4 10] [2 2 2])" "(stats [3 4 10])" "sum" "(ns new-stuf.core-test (:use (clojure pprint repl)))" "(use new-stuf.core-test)" "sum" "(map (comp (partial * 2) (partial + 2)) [1 2 3] [4 5 6])" "(map (comp (partial * 2) (partial + 2)) [1 2 3])" "(map (partial * 2) (partial + 2) [1 2 3])" "(map (partial + 2) [1 2 3] [4 5 6])" "(map (partial * 2) [1 2 3] [4 5 6])" "(map (partial * 2) [1 2 3])" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head  \" - \" tail)) )" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head + \" - \" tail)) )" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head)) )" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial head & tail] (pprint (str f \" - \" initial \" - \" head)) )" "(defn myreduce [f initial coll] (pprint (str f \" - \" initial \" - \" coll)) (reduce f initial coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (pprint (str f \" - \" initial \" - \" coll)) (reduce f initial coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (str f \" - \" initial \" - \" coll) (reduce f initial coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (str f \" - \" initial \" - \" coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (str initial \" - \" initial \" - \" coll))" "(defn myreduce [f inital coll] (str initial \" - \" initial \" - \" coll))" "(drop 2 [1 2 3 4 5])" "'gutenmorgan" "(drop 2 [1 2 3 4 5])" " (loop [x 5
         result []]
    (if (> x 0)
      (recur (dec x) (conj result (+ 2 x)))
      result))" "(sort (rest (reverse [2 5 4 1 3 6])))" "((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5)" "(= 1 (let [z 1] z))" "(= 1 (let [z 1]) z)" "(= 4 (let [y 2 z 2] (+ y z)))" "(= 10 (let [x 8 y 2] (+ x y)))" "(= 10 (let [x 5 y 5] (+ x y)))" "(- 5 3 1)" "(- 5 3)" "((partial * 3) 5)" "((partial * 2) 5)" "(partial * 2) 5)" "(*1)" "(partial * 2 5)" "(apply *1)" "(partial * 2 5)" "((fn dbl [n] (* 2 n)) 7)" "((fn [n] (* 2 n)) 7)" "((fn [n] (* 2 n)))" "(#(* % 2) 7)" "(#(% * 2) 7)" "(#(% *2) 7)" "((partial * 2) 7)" "(partial *2 5)" "partial *2 5" "((partial *2) 7)" "(rest [10 20 30 40])" "(= {:a 1, :b 2, :c 3} (conj {:a 1} [:b 2] [:c 3]))" "(conj '(3 4) 3 2 1)" "(conj '(3 4) 2 1)" "(conj '(3 4 2 1))" "(.toUpperCase \"hello weird\")" "'goodevening-erpa" "(re-find #\"z\" \"erpa\")" "(re-find #\"a\" \"erpa\")" "(doc re-find)" "(yo \"erpa\")" "(yo \"erpa\" \"detpa\")" "(doc yo)" "(:b (:d bz))" "((:b (:d bz)))" "((:b :d bz))" "(:d bz)" "([:d :b] bz)" "(def bz {:a \"e\" :d {:b \"z\"}})" "(def bz {:a \"e\" {:b \"z\"}})" "(def bz {:a \"e\" {:b -}})" "(def bz {:a + {:b -}})" "((:a bz) 2 3) " "(def bz {:a +})" "(* 1/3 10.0)" "(* 1/3 10)" "(/ 10.0 3.0)" "(pprint (macroexpand '(hello \"yew\")))" "(pprint (macroexpand (time (print \"timing\"))))" "(pprint (macroexpand '(time (print \"timing\"))))" "(macroexpand '(time (print \"timing\")))" "(macroexpand (time (print \"timing\")))" "(time (print \"timing\"))" "(doc time)" "(pprint (macroexpand '(hello \"yew\")))" "(pprint (macroexpand (hello \"yew\")))" "(macroexpand (hello \"yew\"))" "(infix_ (9 + 2))" "(defmacro infix_ [form] `(~(second form) ~(first form) ~(nth form 2)))" "(infix (9 + 2))" "(meta #'infix)" "(defmacro infix [form]
  (list (second form) (first form) (nth form 2)))" "(doc macroexpand)" "(macroexpand (hello \"yew\"))" "(macroexpand hello \"yew\")" "(hello \"yew\")" "(meta #'hello)" "(meta 'hello)" "(meta hello)" "(defmacro hello [x] (str \"hello, \" x))" "@br" "(compare-and-set! br 5 13)" "(doc compare-and-set!)" "@br" "(reset! br 5)" "(doc set!)" "(set! br 5)" "(def br (atom 0))" "@the-world" "(= 0 (dosync ref-set the-world 0))" "(doc ref-set)" "@the-world" "(= 0 (dosync ref-set the-world 0))" "(doc dosync)" "(doc do)" "(dosync (alter the-world #(str % \"!\")))" "(dosync (alter the-world #(str % !)))" "(dosyn (alter the-world #(str % !)))" "@the-world" "(dosync (ref-set the-world \"erpa\") @the-world)" "(do-sync (ref-set the-world \"erpa\") @the-world)" "(= \"hello\" @the-world)" "@the-world" "(= 'hello @the-world)" "the-world" "(def bizarro-world (ref {}))" "(def the-world (ref \"hello\"))" "(def the-world (ref \"hello\"))
(def bizarro-world (ref {}))" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str  street-address \", \" city \", \" state)))" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str street-address city state)))" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str street-address ciy state)))" "(def test-address
  {:street-address \"123 Test Lane\"
   :city \"Testerville\"
   :state \"TX\"})" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str street-address ciy state)))" "((fn [[a b]] (str b a)) [:f :b])" "(#(str %2 %1) :f :b)" "(#(str %2 %1) [:f :b])" "((#([[a b]] (str b a))) [:f :b])" "(#([[a b]] (str b a))) [:f :b]" "((#([[a b]] (str b a))) [:foo :bar])" "((#([[a b]] (str b a)) [:foo :bar]))" "((fn [[a b]] (str b a)) [:f :b])" "(#([[a b]] (str b a)) [:foo :bar])" "(#([a b] (str b a)) [:foo :bar])" "(is-even? 2)" "(is-even? 1)" "(is-even? 0)" "(is-even? 13)" "(doc recur)" "((comp dec dec) 10)" "(doc comp)" "(== 2 2.0)" "'gutenmorgan" "(Long/toString (swap! adom inc) 36)" "@adom" "(Long/toString (swap! adom inc) 36)" "@adom" "(Long/toString (swap! adom inc) 36)" "(Long/toString (swap! adom inc) 36 @adom)" "(swap! adom inc)" "(swap! @adom inc)" "@(swap! @adom inc)" "@(swap! adom inc)" "(Long/toString 10000 36)" "(Long/toString @(swap! adom inc) 36 @adom)" "(Long/toString (swap! adom inc) 36 @adom)" "(Long/toString ((swap! adom inc) 36) @adom)" "adom" "(Long/toString (swap! adom inc) @adom)" "(Long/toString @(swap! @adom inc) @adom)" "(Long/toString @(swap! adom inc) @adom)" "(let [id (swap! adom inc) id (Long/toString @adom 36)] id)" "@adom" "(let [id (swap! adom inc) id (Long/toString id 36)] id)" "(let [id (swap! adom inc) id (Long/toString id 36)] )" "(Long/toString 10 16)" "(Long/toString 10005 16)" "(Long/toString 10005 8)" "(Long/toString 10005 37)" "(Long/toString 10005 64)" "(Long/toString 10005 36)" "(Long/toString adom 36)" "(swap! adom - 1)" "(swap! adom inc)" "(reset! adom 13)" "adom" "(swap! adom inc)" "(swap! counter inc)" "(meta adom)" "(def adom (atom 122))" "(meta wm)" "*print-meta*" "wm" "(def wm (with-meta [1 2 3] {:my \"meta\"}))" "(list a 23)" "(apply (list a 23))" "(apply list a 23)" "(list 1 2)" "(doc list)" "(apply list (a 23))" "(def a 42)" "c" "b" "a" "(apply list (barney 23))" "(apply list (barney 23)))" "(list barney 23)" "`barney" "bareny" "`cc" "'cc" "cc" "'b" "`b" "b" "(doc binding)" "(seq \"thirteen\")" "(doc seq)" "(seq {{:a 1} {:b 2}})" "(reduce + (range 10))" "(reduce (range 10))" "(doc str)" "(print *1)" "(str (interpose \\, \"asdf\"))" "(print str)" "(str (interpose \\, \"asdf\"))" "(interpose \\, \"asdf\")" "(doc interpose)" "(doc apply)" "(apply str (interpose \\: \"asdf\"))" "(doc vector)" "(interleave [:a :b ] [1 2 3])" "(interleave [:a :b :C] [1 2 ])" "(interleave [:a :b :C] [1 2 3])" "(doc interleave)" "(doc cycle)" "(doc key)" "(apropos \"key\")" "(doc apropos)" "(apropos keys)" "(apropos key)" "(apropos ::)" "(apropos '::)" "(:super (::prototype cc))" "(::prototype cc)" "(:prototype cc)" "(:prototype c)" "cc" "(def cc (beget {:sub 0} {:super 1}))" "(beget {:sub 0} {:super 1})" "(defn beget [o p] (assoc o ::prototype p))" "(def bar (with-meta 'bar {:meta-tag \"katang\"}) 23)" "(def bar (with-meta bar {:meta-tag \"katang\"}) 23)" "(def (with-meta bar {:meta-tag \"katang\"}) 23)" "^square" "(def (with-meta (symbol \"bar\") {:meta-tag \"katang\"}) 23)" "(def (with-meta (symbol \"bar\") {:meta-tag \"katang\"}) (fn [] 23))" "(def (with-meta (symbol \"bar\") {:meta-tag \"katang\"}) (fn [] (23)))" "(def (with-meta bar {:meta-tag \"katang\"}) (fn [] (23)))" "(def (with-meta 'bar {:meta-tag \"katang\"}) (fn [] (23)))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) (fn [] (23)))" "(def (fn (with-meta 'bar {:meta-tag \"katang\"}) [] (23)))" "(def fn (with-meta 'bar {:meta-tag \"katang\"}) [] (23))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) [] (23))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) (23))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) bar (23))" "(meta #'square)" "square" "(defn ^{:erpa \"derpa\"} square [x] (* x x))" "(:a b)" "(def b {:a (with-meta 'foo {:meta-tag \"foo\"})})" "(foo \"hoo\")" "(foo)" "foo" "(pprint #'foo)" "(pprint 'foo)" "(pprint foo)" "(meta (:a {:a (with-meta 'foo {:meta-tag \"foo\"})}))" "(pprint square)" "(pprint 'square)" "(pprint #'square)" "(meta #'square)" "(defn square ^:dynamic [x] (* x x))" "(meta 'square)" "(meta #square)" "(square 11)" "(meta #'square)" "(defn square ^{:erpa \"derpa\"} [x] (* x x))" "(defn square (with-meta #'square {:erpa \"derpa\"}) [x] (* x x))" "(defn square (with-meta 'square {:erpa \"derpa\"}) [x] (* x x))" "(def square (with-meta 'square {:erpa \"derpa\"}) [x] (* x x))" "(meta #'square)" "(with-meta 'square {:erpa \"derpa\"})" "(pprint (meta #'*print-meta*))" "*print-meta*" "(doc *print-meta*)" "(set! *print-meta* true)" "(doc with-meta)" "(doc doc)" "barney" "(doc doc)" "(in-ns 'user)" "(doc doc)" "(doc pprint)" "(ns new-stuf.core-test (:use (clojure pprint repl)))" "(ns new-stuf.core-test (:use clojure.pprint clojure.repl.doc))" "(ns new-stuf.core-test (:use [clojure.pprint clojure.repl.doc]))" "(in-ns 'user)" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl.doc)))" "(doc pprint)" "(doc map)" "(ns new-stuf.core-test (:use clojure.repl) (:use clojure.pprint))" "(ns new-stuf.core-test (:useclojure.repl) (:use clojure.pprint))" "(in-ns 'user)" "(doc map)" "(ns new-stuf.core-test (:require [clojure.repl :refer :all]) (:use clojure.pprint))" "(ns new-stuf.core-test (:require clojure.repl :refer :all) (:use clojure.pprint))" "(ns new-stuf.core-test (:require ( clojure.repl :refer :all)) (:use clojure.pprint))" "(in-ns 'user)" "(clojure.repl/doc map)" "(doc map)" "(ns new-stuf.core-test (:use ( clojure.repl)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl.doc)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl/)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl)))" "(doc doc)" "(in-ns 'user)" "(doc map)" "(ns new-stuf.core-test (:use (clojure.pprint clojure.tools.nrepl.*)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.tools.nrepl)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.tools)))" "(ns new-stuf.core-test (:use (clojure.pprint user/doc)))" "(ns new-stuf.core-test (:use clojure.pprint))" "(ns new-stuf.core-test (:require user))" "(ns new-stuf.core-test (:use user))" "(ns new-stuf.core-test)" "*ns*" "*ns" ";(in-ns 'new-stuf.core-test)" "*2" "*1" "(pprint a)" "(pprint (a))" "pp" "a" "(doc pp)" "pp" "(pp (a))" "(pp a)" "(print a)" "a")