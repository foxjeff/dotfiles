;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(erp)" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc) (reset! x54 {(ensure x5) (ensure x4)})))" "(erp)" "@x54" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)) (reset! x54 {(ensure x5) (ensure x4)}))" "@x54" "(val (first @x54))" "(key (first @x54))" "(keys @x54)" "(type (@x54 1))" "(type (@x54 0))" "(type @x54)" "(type x54)" "(type (val x54))" "(type (val @x54))" "(type (key x54))" "(type (key @x54))" "@x54" "(erp)" "@x54" "(dosync (ref-set x5b (java.util.Date.)))" "(type java.util.Date)" "(type java.util.Date.)" "(dosync (alter x5b (java.util.Date.)))" "x5b" "(def x5b (ref (java.util.Date.)))" "(def x5b (ref (java.util.date)))" "(erp)" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)) (reset! x54 {@x5 @x4}))" "(reset! x54 {@x5 @x4})" "@x54" "(erp)" "(defn erp [] (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)))" "(erp)" "@x54" "erp" "@x54" "erp" "@x54" "x54" "(def x54 (atom {@x5 @x4}))" "(def erp (dosync (ref-set x5 (java.util.Date.)) (alter x4 inc)))" "@x5" "@x4" "x45" "(dosync (ref-set x5 (java.util.Date.)) (alter x4 inc))" "(doc doseq)" "(doseq (ref-set x5 (java.util.Date.)) (alter x4 inc))" "x45" "(def x45 {@x5 @x4})" "(def x5 (ref (java.util.Date.)))" "(def x4 (ref 23))" "(doc alter)" "x3" "(inc (:a @x3))" "(swap! x3 (inc (:a @x3)))" "(:a x3)" "(:a @x3)" "(swap! x3 (inc (:a x3)))" "(def x3 (atom {:a 23}))" ";(reset! x2 ({(java.util.Date.) 13}))" "@x2" "(def x2 (atom{(java.util.Date.) 13}))" "@@x2" "@x2" "(reset! x2 (atom{(java.util.Date.) 13}))" "x2" "(doc reset!)" "@x2" "x2" "(first x2)" "(val @x2)" "(first @x2)" "@x2" "(val (first @x2))" "(reset! x2 (atom{(java.util.Date.) 13}))" "(val (first @x2))" "@x2" "(swap! x2 {(java.util.Date.) (inc (val (first @x2)))})" "(val (first @x2))" "(val @x2)" "(doc val)" "@x2" "(def x2 (atom{(java.util.Date.) 13}))" "(def x2 (atom{java.util.Date. 13}))" "(def x2 {java.util.Date. 13})" "(java.util.Date.)" "(Date.)" "Date." "(swap! x identity)" "(swap! x identity?)" "(realized? x)" "@x" "x" "(def x (atom 13))" "x" "(doc swap!)" "(doc reset!)" "(realized? kat)" "kat" "(realized? kat)" "(def kat (map inc [1 2 3]))" "(def kat (map #(inc) [1 2 3]))" "(realized? foot)" "(doc realized?)" "(realized? box)" "@box" "(realized? box)" "(deliver box :turtles-all-the-way-down-here)" "(realized? box)" "(def box (promise))" "(realized? later)" "later" "(realized? later)" "(realized? box)" "(delivered? box)" "(doc realized?)" "(doc deliver)" "(doc promise)" "@box" "(deliver box :turtles-all-the-way-down)" "@box" "box" "(def box (promise))" "(dotimes [i 5] (future (prn i)))" "@later" "later" "(meta #'later)" "#'later" "@(*5)" "@(type *4)" "(type *3)" "@later" "(type *1)" "later" "(type later)" "(def later (delay (prn \"Adding\") (+ 1 2)))" "(<= 60 88)" "(if-not true 42 (dbg(/ 1 3)))" "(if-not true 42 (dbg(/ 1 0)))" "(if true 42 (dbg(/ 1 0)))" "(barney)" "()" ")" "(if true 42 (/ 1 0))" "(type true)" "(if true 42 1/0)" "(/ 1 0)" "(pprint (keys (ns-interns *ns*)))" "(keys (ns-interns *ns*))" "(ns-interns *ns*)" "(defrecord TreeNode [val l r])" "(map #(re-seq #\"(joy)\" (str %)) ee)" "(map #(re-seq #\"([joy])\" (str %)) ee)" "(map #(re-seq #\"joy\" (str %)) ee)" "(map #(re-seq #(\"joy\") (str %)) ee)" "(map #(re-seq #\"joy\" (str %)) ee)" "(map #(re-matches #\"joy\" (str %)) ee)" "(map #(re-find #\"joy\" (str %)) ee)" "(map #(re-mather #\"joy\" (str %)) ee)" "(map #(re-groups (re-matcher #\"joy\" (str %))) ee)" "(map #((re-groups re-matcher #\"joy\" (str %))) ee)" "(map #((re-groups re-mather #\"joy\" (str %))) ee)" "(map #(re-mather #\"joy\" (str %)) ee)" "(map #(re-find #\"joy\" (str %)) ee)" "(map #(re-find #\"joy\" %) ee)" "(map #(re-find #\"joy\") ee)" "(type ee)" "(typeee)" "ee" "(doc ns-interns)" "(ns-interns *ns*)" "(count (ns-interns *ns*))" "(*ns* interns)" "(interns *ns*)" ";(def (TreeNode. 5 nil nil)" "(doc TreeNode.)" "(doc TreeNode)" "(type TreeNode.)" "(type TreeNode)" "(TreeNode. 5 nil nil)" "(TreeNode 5 nil nil)" "(defrecord TreeNode [val l r])" "(get2 (beget {:sub 0} {:super 1}) :super)" "(defn get2 [m k]
  (when m
    (if-let [[_ v] (find m k)]
      v
      (recur (::prototype m) k))))" "(get (beget {:sub 0} {:super 1}) :super)" "(find {:erpa 1} :erpa)" "(get {:erpa 1} :erpa)" "(assoc {:sub 0} ::erpa {:super 1})" "(assoc {:sub 0} {::erpa {:super 1}})" "(assoc {:sub 0} {:super 1})" "(doc assoc)" "(beget {:sub 0} {:super 1} )" "(defn beget [o p] (assoc o ::prototype p))" "(ee 'clojure.set)" "(sort ee)" "(def ee (set (map ns-name allns)))" "(sort ee)" "(contains? ee 'clojure)" "(contains? ee 'clojure.set)" "(ee 'clojure.set)" "(ee 'clojure)" "(count ee)" "(def ee (set (map ns-name bb)))" "(dd :c)" "(cc :c)" "(def dd(set cc))" "(def dd(set cc)" "(set cc)" "(hash-map cc)" "(into {} cc)" "(keys cc)" "(get cc ':a)" "cc" "(get cc :a)" "(cc :a)" "(def cc [:a :b :c])" "(find cc 'clojure.set)" "(doc get)" "(type 'clojure.set)" "(type (first cc))" "(type first cc)" "(get cc clojure.set)" "(get cc 'clojure.set)" "(get cc 'clojure)" "cc" "(def cc (into [] (map ns-name bb)))" "(into [] (map ns-name bb))" "(into [] (ns-name bb))" "(vec (ns-name bb))" "bb" "(type(ns-name *ns*))" "(map ns-name bb)" "(ns-name *ns*)" "(type *ns*)" "(count (ns-map (nth bb 4)))" "(count (ns-map (nth bb 2)))" "(count (ns-map (second bb)))" "(count (ns-map (first bb)))" "(count (ns-map first bb))" "(map first bb)" "(first bb)" "'bb" "'bbb" "#'*ns*" "(count bb)" "(get bb 'clojure)" "(bb 'clojure)" "(def bb *2)" "(count(into [](take 5 allns)))" "(into [](take 5 allns))" "(into {}(take 5 allns))" "(take 5 allns)" "(apply type (take 1 allns))" "(type (take 1 allns))" "(get allns 'clojure.test)" "(get allns \"clojure\")" "(get allns 'clojure)" "(allns 'clojure)" "(take 5 allns)" "(count allns)" "(class allns)" "(type allns)" "(count (allns))" "(def allns (all-ns))" "(count (partition 5 allns))" "(count (partition 1 allns))" "(count (parition 1 allns))" "(count (take 5 allns))" "(count (take 1 allns))" "(take 1 allns)" "(take 5 allns)" "'" "(into {} allns)" "(into {} (all-ns))" "(into {} (ns-all))" "(allns 'clojure)" "(count allns)" "(def allns (vector(all-ns)))" "(doc all-ns)" "((all-ns) 'clojure)" "(contains? (all-ns) 'clojure)" "(count(all-ns))" "(all-ns)" "(find-ns *ns*)" "(find-ns 'fooz)" "(find-ns 'String)" "(doc find-ns)" "((ns-map *ns*) 'fooz)" "((ns-map 'clojure.core) 'fooz)" "((ns-map 'clojure.core) 'String)" "(doc ns-map)" "(count (ns-interns *ns*))" "(def fooz \"baz\")" "(count (ns-interns *ns*))" "(count (ns-refers 'user))" "(count (ns-refers 'new-stuf.core-test))" "(count (ns-refers 'new-stuf.core))" "(count (ns-refers 'clojure.core))" "(count (ns-interns *ns*))" "(count (ns-imports *ns*))" "(count (ns-refers *ns*))" "(count (ns-refers *ns*)
                      )" "(ns-map 'clojure.core)" "(ns-map 'new-stuf.core)" "(lu3 \"a1\")" "(lue \"a1\")" "(defn lu3 [pos] (let [[f r] (map int pos)] (prn [f r])))" "(defn lu3 [pos] (let [[f r]] (map int pos) (prn [f r])))" "(map int \"a1\")" "(joy.chess/initial-board)" "((joy.chess/initial-board) 56)" "(joy.chess/initial-board 56)" "joy.chess/initial-board" "initial-board" "(foor2 \\1)" "(defn foor2 [x] (->> (int \\0) (- (int x))))" "(foor \\1)" "(defn foor [x] (->> (int \\0) (- (int x)) (- 8) (* 8)))" "(- -1 8)" "(- 48 49)" "(int \\1)" "(take 8 (range (int \\a) (+ 8 (int \\a))))" "(take 2 (range (int \\a) (+ 8 (int \\a))))" "(take 2 (range (int \\a) ((+ 8 int \\a))))" "(take 2 (range (int \\a) 8))" "(take 2 (range (int \\a)))" "(take 2 (range \\a))" "(int \\0)" "(int \\a)" "(into {} (vec '([:a 1] [:a 3])))" "(vec '([:a 1] [:a 3]))" " (seq '([:a 1] [:a 3]))" " (into {} '([:a 1] [:a 3]))" " (first '([:a 1] [:a 3]))" " (first ([:a 1] [:a 3]))" " (into {} ([:a 1] [:a 3]))" " (seq ([:a 1] [:a 3]))" "(vec (seq ([:a 1] [:a 3])))" "(vec ([:a 1] [:a 3]))" "(vec {:a 1 :b 2})" "(vector 1 23 [3 5] 16)" "(vector 1 23 [3 5])" "(vec '(1 2 3))" "(vec [1 2] [3 4])" "(nthrest [1 2 3] 0)" "(nth [1 2 3] 0)" "(nthnext [1 2 3] 0)" ";is there a way to get ([:a 1] [:a 3] [:b 1] [:b 3]) into [{:a 1} {:a 3} {:b1} {:b3}] ?" "(apply array-map boo)" "(apply array-map [:a 1 :b 2])" "(hash-map '(:a 1 :b 2))" "(apply hash-map boo)" "boo" "(into {} boo)" "(def boo (for [x [:a :b], y (range 5) :when (odd? y)] [x y]))" "(into {} (for [x [:a :b], y (range 5) :when (odd? y)] [x y]))" "(for [x [:a :b], y (range 5) :when (odd? y)] [x y])" "(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))" "(doc for)" "(for [x [:a :b], y (range 5) :when (odd? y)] [x y])" "(for [x [:a :b], y (range 5) :when (odd? y)])" "'yerpado" "valor" "`(foo ~@[1 2 3])" "`(foo ~[1 2 3])" "(foob 1)" "(type #'foob)" "(type foob)" "(type 'foob)" "(source foob)" "(source 'foob)" "(foob 2)" "(pprint (macroexpand '(or a b c d)))" "(macroexpand '(hello \"yew\"))" "(pprint (macroexpand '(hello \"yew\")))" "(meta #'hello)" "(defmacro hello [x] (str \"hello, \" x))" "(pprint (macroexpand '(hello \"yew\")))" "(macroexpand '(ignore (+ 1 2)))" "(macroexpand '(ignore (dbg (+ 1 2))))" "(macroexpand '(rev str \"hi\" (+ 1 2)))" "(macroexpand (rev str \"hi\" (+ 1 2)))" "(rev str \"hi\" (+ 1 2))" "(defmacro rev [fn & args] (cons fn (reverse args)))" "(defmacro rev [fn & args] (cons fun (reverse args)))" "(ignore (dbg (+ 1 2)))" "(macroexpand (ignore (dbg (+ 1 2))))" "(macroexpand (ignore (+ 1 2)))" "(ignore (+ 1 2))" "(defmacro ignore [expr] nil)" "(doc realized?)" "(reductions + 0 [1 2 3])" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head  \" - \" tail)) )" "(doc reductions)" "(take 10 fib)" "(fib)" "(doc apply)" "(meta *2)" "*3" "*1" "(apply hash-map [:a 1 :b 2])" "(set! *print-meta* true)" "(apply hash-map [:a 1 :b 2])" "(apply array-map [:a 1 :b 2])" "(interleave [:a 1 :b 2])" "(zipmap [:a 1 :b 2])" "(hash-map '(:a 1 :b 2))" "(hash-map (:a 1 :b 2))" "(hash-map :a 1 :b 2)" "(doc hash-map)" "(hash-map [:a 1 :b 2])" "(doc concat)" "(doc map-indexed)" "(map-indexed (fn [index element] (str index \". \" element)) [\"erlang\" \"ruby\" \"haskell\"])" "(take 3 (repeatedly ((* 10 (rand)))))" "(take 3 (repeatedly (* 10 (rand))))" "(* 10 (rand))" "(Math/floor 10.23)" "Math/floor 10.23" "(* 10 (rand))" "(rand)" "(take 3 (* 10 (repeatedly rand )))" "(take 3 (repeatedly rand ))" "(take 3 (repeatedly (* (rand) 10.0)))" "(take 3 (repeatedly (* (rand) 10)))" "(take 3 (repeatedly (* rand 10)))" "(take 5 (iterate (fn [x] (str x \"o\")) \"y\"))" "(take 10 (iterate (fn [x] (if (odd? x) (+ 1 x) (/ x 2))) 10))" "(take 10 (iterate inc 0))" "(if false \"fooey\")" "(if false \"fooey\" \"barney\")" "(if true \"fooey\" \"barney\")" "(if true \"fooey\")" "(type (drop 1 fool))" "(type fool)" "(def zz 23)" "(barney)" "clojure.tools.namespace.find" "(require '[clojure.tools.namespace] :verbose)" "(require '[org.clojure/tools.namespace] :verbose)" "(require '[org.clojure/tool.namespace] :verbose)" "(require '(org.clojure/tool.namespace))" "(alembic.still/load-project)" "(require '[alembic.still] :verbose)" "(def a 1)" "a" "(barney)" "(apply list (barney 23))" "(apply map vector [[1 2 3]])" "(apply map vector [1 2 3])" "(map vector [1 2 3])" "(vector 1 2 3 [4 5])" "(vector 1 2 3)" "(vector [1 2 3 [4 5]])" "(vector [1 2 3])" "(seq (concat [1 2 3] {:a 13 :b 11}))" "(concat [1 2 3] {:a 13 :b 11})" "(concat [1 2 3] [4 5 6])" "(sort > [3 5 4])" "(sort < [3 5 4])" "(sort [3 5 4])" "((seq (seq [1 2 3]) [4 5 6]))" "(seq [1 2 3] [4 5 6])" "(map *1 [3 4 10])" "(comp sum count avg)" "(map (comp sum count avg) [3 4 10])" "(map #(% [3 4 10] [2 2 2]) [sum count avg] )" "(map #(% [3 4 10]) [sum count avg] )" "(map #(% numbers) [sum count avg] [3 4 10])" "(stats [3 4 10] [2 2 2])" "(stats [3 4 10])" "sum" "(ns new-stuf.core-test (:use (clojure pprint repl)))" "(use new-stuf.core-test)" "sum" "(map (comp (partial * 2) (partial + 2)) [1 2 3] [4 5 6])" "(map (comp (partial * 2) (partial + 2)) [1 2 3])" "(map (partial * 2) (partial + 2) [1 2 3])" "(map (partial + 2) [1 2 3] [4 5 6])" "(map (partial * 2) [1 2 3] [4 5 6])" "(map (partial * 2) [1 2 3])" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head  \" - \" tail)) )" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head + \" - \" tail)) )" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial [head & tail]] (pprint (str f \" - \" initial \" - \" head)) )" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial head & tail] (pprint (str f \" - \" initial \" - \" head)) )" "(defn myreduce [f initial coll] (pprint (str f \" - \" initial \" - \" coll)) (reduce f initial coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (pprint (str f \" - \" initial \" - \" coll)) (reduce f initial coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (str f \" - \" initial \" - \" coll) (reduce f initial coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (str f \" - \" initial \" - \" coll))" "(myreduce + 0 [1 2 3])" "(defn myreduce [f initial coll] (str initial \" - \" initial \" - \" coll))" "(defn myreduce [f inital coll] (str initial \" - \" initial \" - \" coll))" "(drop 2 [1 2 3 4 5])" "'gutenmorgan" "(drop 2 [1 2 3 4 5])" " (loop [x 5
         result []]
    (if (> x 0)
      (recur (dec x) (conj result (+ 2 x)))
      result))" "(sort (rest (reverse [2 5 4 1 3 6])))" "((fn foo [x] (when (> x 0) (conj (foo (dec x)) x))) 5)" "(= 1 (let [z 1] z))" "(= 1 (let [z 1]) z)" "(= 4 (let [y 2 z 2] (+ y z)))" "(= 10 (let [x 8 y 2] (+ x y)))" "(= 10 (let [x 5 y 5] (+ x y)))" "(- 5 3 1)" "(- 5 3)" "((partial * 3) 5)" "((partial * 2) 5)" "(partial * 2) 5)" "(*1)" "(partial * 2 5)" "(apply *1)" "(partial * 2 5)" "((fn dbl [n] (* 2 n)) 7)" "((fn [n] (* 2 n)) 7)" "((fn [n] (* 2 n)))" "(#(* % 2) 7)" "(#(% * 2) 7)" "(#(% *2) 7)" "((partial * 2) 7)" "(partial *2 5)" "partial *2 5" "((partial *2) 7)" "(rest [10 20 30 40])" "(= {:a 1, :b 2, :c 3} (conj {:a 1} [:b 2] [:c 3]))" "(conj '(3 4) 3 2 1)" "(conj '(3 4) 2 1)" "(conj '(3 4 2 1))" "(.toUpperCase \"hello weird\")" "'goodevening-erpa" "(re-find #\"z\" \"erpa\")" "(re-find #\"a\" \"erpa\")" "(doc re-find)" "(yo \"erpa\")" "(yo \"erpa\" \"detpa\")" "(doc yo)" "(:b (:d bz))" "((:b (:d bz)))" "((:b :d bz))" "(:d bz)" "([:d :b] bz)" "(def bz {:a \"e\" :d {:b \"z\"}})" "(def bz {:a \"e\" {:b \"z\"}})" "(def bz {:a \"e\" {:b -}})" "(def bz {:a + {:b -}})" "((:a bz) 2 3) " "(def bz {:a +})" "(* 1/3 10.0)" "(* 1/3 10)" "(/ 10.0 3.0)" "(pprint (macroexpand '(hello \"yew\")))" "(pprint (macroexpand (time (print \"timing\"))))" "(pprint (macroexpand '(time (print \"timing\"))))" "(macroexpand '(time (print \"timing\")))" "(macroexpand (time (print \"timing\")))" "(time (print \"timing\"))" "(doc time)" "(pprint (macroexpand '(hello \"yew\")))" "(pprint (macroexpand (hello \"yew\")))" "(macroexpand (hello \"yew\"))" "(infix_ (9 + 2))" "(defmacro infix_ [form] `(~(second form) ~(first form) ~(nth form 2)))" "(infix (9 + 2))" "(meta #'infix)" "(defmacro infix [form]
  (list (second form) (first form) (nth form 2)))" "(doc macroexpand)" "(macroexpand (hello \"yew\"))" "(macroexpand hello \"yew\")" "(hello \"yew\")" "(meta #'hello)" "(meta 'hello)" "(meta hello)" "(defmacro hello [x] (str \"hello, \" x))" "@br" "(compare-and-set! br 5 13)" "(doc compare-and-set!)" "@br" "(reset! br 5)" "(doc set!)" "(set! br 5)" "(def br (atom 0))" "@the-world" "(= 0 (dosync ref-set the-world 0))" "(doc ref-set)" "@the-world" "(= 0 (dosync ref-set the-world 0))" "(doc dosync)" "(doc do)" "(dosync (alter the-world #(str % \"!\")))" "(dosync (alter the-world #(str % !)))" "(dosyn (alter the-world #(str % !)))" "@the-world" "(dosync (ref-set the-world \"erpa\") @the-world)" "(do-sync (ref-set the-world \"erpa\") @the-world)" "(= \"hello\" @the-world)" "@the-world" "(= 'hello @the-world)" "the-world" "(def bizarro-world (ref {}))" "(def the-world (ref \"hello\"))" "(def the-world (ref \"hello\"))
(def bizarro-world (ref {}))" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str  street-address \", \" city \", \" state)))" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str street-address city state)))" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str street-address ciy state)))" "(def test-address
  {:street-address \"123 Test Lane\"
   :city \"Testerville\"
   :state \"TX\"})" "  (= \"123 Test Lane, Testerville, TX\"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str street-address ciy state)))" "((fn [[a b]] (str b a)) [:f :b])" "(#(str %2 %1) :f :b)" "(#(str %2 %1) [:f :b])" "((#([[a b]] (str b a))) [:f :b])" "(#([[a b]] (str b a))) [:f :b]" "((#([[a b]] (str b a))) [:foo :bar])" "((#([[a b]] (str b a)) [:foo :bar]))" "((fn [[a b]] (str b a)) [:f :b])" "(#([[a b]] (str b a)) [:foo :bar])" "(#([a b] (str b a)) [:foo :bar])" "(is-even? 2)" "(is-even? 1)" "(is-even? 0)" "(is-even? 13)" "(doc recur)" "((comp dec dec) 10)" "(doc comp)" "(== 2 2.0)" "'gutenmorgan" "(Long/toString (swap! adom inc) 36)" "@adom" "(Long/toString (swap! adom inc) 36)" "@adom" "(Long/toString (swap! adom inc) 36)" "(Long/toString (swap! adom inc) 36 @adom)" "(swap! adom inc)" "(swap! @adom inc)" "@(swap! @adom inc)" "@(swap! adom inc)" "(Long/toString 10000 36)" "(Long/toString @(swap! adom inc) 36 @adom)" "(Long/toString (swap! adom inc) 36 @adom)" "(Long/toString ((swap! adom inc) 36) @adom)" "adom" "(Long/toString (swap! adom inc) @adom)" "(Long/toString @(swap! @adom inc) @adom)" "(Long/toString @(swap! adom inc) @adom)" "(let [id (swap! adom inc) id (Long/toString @adom 36)] id)" "@adom" "(let [id (swap! adom inc) id (Long/toString id 36)] id)" "(let [id (swap! adom inc) id (Long/toString id 36)] )" "(Long/toString 10 16)" "(Long/toString 10005 16)" "(Long/toString 10005 8)" "(Long/toString 10005 37)" "(Long/toString 10005 64)" "(Long/toString 10005 36)" "(Long/toString adom 36)" "(swap! adom - 1)" "(swap! adom inc)" "(reset! adom 13)" "adom" "(swap! adom inc)" "(swap! counter inc)" "(meta adom)" "(def adom (atom 122))" "(meta wm)" "*print-meta*" "wm" "(def wm (with-meta [1 2 3] {:my \"meta\"}))" "(list a 23)" "(apply (list a 23))" "(apply list a 23)" "(list 1 2)" "(doc list)" "(apply list (a 23))" "(def a 42)" "c" "b" "a" "(apply list (barney 23))" "(apply list (barney 23)))" "(list barney 23)" "`barney" "bareny" "`cc" "'cc" "cc" "'b" "`b" "b" "(doc binding)" "(seq \"thirteen\")" "(doc seq)" "(seq {{:a 1} {:b 2}})" "(reduce + (range 10))" "(reduce (range 10))" "(doc str)" "(print *1)" "(str (interpose \\, \"asdf\"))" "(print str)" "(str (interpose \\, \"asdf\"))" "(interpose \\, \"asdf\")" "(doc interpose)" "(doc apply)" "(apply str (interpose \\: \"asdf\"))" "(doc vector)" "(interleave [:a :b ] [1 2 3])" "(interleave [:a :b :C] [1 2 ])" "(interleave [:a :b :C] [1 2 3])" "(doc interleave)" "(doc cycle)" "(doc key)" "(apropos \"key\")" "(doc apropos)" "(apropos keys)" "(apropos key)" "(apropos ::)" "(apropos '::)" "(:super (::prototype cc))" "(::prototype cc)" "(:prototype cc)" "(:prototype c)" "cc" "(def cc (beget {:sub 0} {:super 1}))" "(beget {:sub 0} {:super 1})" "(defn beget [o p] (assoc o ::prototype p))" "(def bar (with-meta 'bar {:meta-tag \"katang\"}) 23)" "(def bar (with-meta bar {:meta-tag \"katang\"}) 23)" "(def (with-meta bar {:meta-tag \"katang\"}) 23)" "^square" "(def (with-meta (symbol \"bar\") {:meta-tag \"katang\"}) 23)" "(def (with-meta (symbol \"bar\") {:meta-tag \"katang\"}) (fn [] 23))" "(def (with-meta (symbol \"bar\") {:meta-tag \"katang\"}) (fn [] (23)))" "(def (with-meta bar {:meta-tag \"katang\"}) (fn [] (23)))" "(def (with-meta 'bar {:meta-tag \"katang\"}) (fn [] (23)))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) (fn [] (23)))" "(def (fn (with-meta 'bar {:meta-tag \"katang\"}) [] (23)))" "(def fn (with-meta 'bar {:meta-tag \"katang\"}) [] (23))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) [] (23))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) (23))" "(defn (with-meta 'bar {:meta-tag \"katang\"}) bar (23))" "(meta #'square)" "square" "(defn ^{:erpa \"derpa\"} square [x] (* x x))" "(:a b)" "(def b {:a (with-meta 'foo {:meta-tag \"foo\"})})" "(foo \"hoo\")" "(foo)" "foo" "(pprint #'foo)" "(pprint 'foo)" "(pprint foo)" "(meta (:a {:a (with-meta 'foo {:meta-tag \"foo\"})}))" "(pprint square)" "(pprint 'square)" "(pprint #'square)" "(meta #'square)" "(defn square ^:dynamic [x] (* x x))" "(meta 'square)" "(meta #square)" "(square 11)" "(meta #'square)" "(defn square ^{:erpa \"derpa\"} [x] (* x x))" "(defn square (with-meta #'square {:erpa \"derpa\"}) [x] (* x x))" "(defn square (with-meta 'square {:erpa \"derpa\"}) [x] (* x x))" "(def square (with-meta 'square {:erpa \"derpa\"}) [x] (* x x))" "(meta #'square)" "(with-meta 'square {:erpa \"derpa\"})" "(pprint (meta #'*print-meta*))" "*print-meta*" "(doc *print-meta*)" "(set! *print-meta* true)" "(doc with-meta)" "(doc doc)" "barney" "(doc doc)" "(in-ns 'user)" "(doc doc)" "(doc pprint)" "(ns new-stuf.core-test (:use (clojure pprint repl)))" "(ns new-stuf.core-test (:use clojure.pprint clojure.repl.doc))" "(ns new-stuf.core-test (:use [clojure.pprint clojure.repl.doc]))" "(in-ns 'user)" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl.doc)))" "(doc pprint)" "(doc map)" "(ns new-stuf.core-test (:use clojure.repl) (:use clojure.pprint))" "(ns new-stuf.core-test (:useclojure.repl) (:use clojure.pprint))" "(in-ns 'user)" "(doc map)" "(ns new-stuf.core-test (:require [clojure.repl :refer :all]) (:use clojure.pprint))" "(ns new-stuf.core-test (:require clojure.repl :refer :all) (:use clojure.pprint))" "(ns new-stuf.core-test (:require ( clojure.repl :refer :all)) (:use clojure.pprint))" "(in-ns 'user)" "(clojure.repl/doc map)" "(doc map)" "(ns new-stuf.core-test (:use ( clojure.repl)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl.doc)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl/)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.repl)))" "(doc doc)" "(in-ns 'user)" "(doc map)" "(ns new-stuf.core-test (:use (clojure.pprint clojure.tools.nrepl.*)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.tools.nrepl)))" "(ns new-stuf.core-test (:use (clojure.pprint clojure.tools)))" "(ns new-stuf.core-test (:use (clojure.pprint user/doc)))" "(ns new-stuf.core-test (:use clojure.pprint))" "(ns new-stuf.core-test (:require user))" "(ns new-stuf.core-test (:use user))" "(ns new-stuf.core-test)" "*ns*" "*ns" ";(in-ns 'new-stuf.core-test)" "*2" "*1" "(pprint a)" "(pprint (a))" "pp" "a" "(doc pp)" "pp" "(pp (a))" "(pp a)" "(print a)" "a" "(def a 23)" "b" "a" "c" "(print map)" "map" "*print-meta*" "(set! *print-meta* true)" "(doc set!)" "(doc aset-boolean)" "aset-boolean" "(var-get '*print-meta*)" "(var-get *print-meta*)" "(var-set *print-meta* true)" "*print-meta*" "(doc var-set)" "(in-ns 'user)" "(use user)" "(use 'user)" "(doc var-set)" "*print-meta*" "(pp c)" "(pprint c)" "(print c)" "(in-ns 'new-stuf.core-test)" "(print c)" "(print b)" "(print map)" "map" "*print-meta*" "(doc clojure.core/*print-meta*)" "(def clojure.core/*print-meta* true)" "(doc clojure.core/*print-meta*)" "(doc *print-meta*)" "(def *print-meta* true)" "(pprint (meta #'*print-meta*))" "(doc *print-meta*)" "(doc map)" "(pprint (meta #'map))" "pprint" "(doc clojure.pprint/pprint)" "(doc 'clojure.pprint/pprint)" "(doc with-meta)" "(in-ns 'new-stuf.core)" "(ns-name 'punter)" "(ns-name 'new-stuf.core)" "(ns-name new-stuf)" "(ns-name user)" "(ns-name 'user)" "ns-name" "(doc with-meta)" "(doc map)" "doc map" "(in-ns 'user)" "(in-ns user)" "(user/doc)" "(find-ns 'user)" "(find-ns user)" "(find-ns)" "(all-ns)" "(user/find-doc map)" "(find-doc map)" "user/find-doc" "user/doc" "find-doc" "doc" "(doc with-meta)" "doc with-meta" "*print-meta*" "*print-meta* true" "*print-meta*" "(pp (meta #'clojure.pprint/pprint))" "(pp (meta #'pp))" "(pp (meta #'with-meta))" "(defn pp [x] (clojure.pprint/pprint x))" "(def pp [x] (clojure.pprint/pprint x))" "pp-str" "(clojure.pprint/pprint (meta #'with-meta))" "clojure.pprint/pprint (meta #'with-meta)" "clojure.pprint/pprint \"erpa\"" "clojure.pprint/pp \"hello\"" "clojure.pprint" "(print (meta #'with-meta))" "(meta #'with-meta)" "(meta #'square)" "(with-meta 'square {:erpa \"derpa\"})" "(with-meta #'square {:erpa \"derpa\"})" "(meta #'square)" "(square 10)" "(defn square [x] (* x x))" "(meta #'in-ns)" "(meta #'ns)" "(meta #'when)" "#'my-hash-map" "'my-hash-map" "my-hash-map" "(with-meta #'my-hash-map {:erpa \"derpa\"})" "(type #'my-hash-map)" "(meta #'my-hash-map)" "(type ^'c)" "(type ^#'c)" "(type #'c)" "(type #c)" "(type 'c)" "(type c)" "(type #'c)" "(meta #'c)" "(def ^:dynamic c \"erpa\")" "^#'clojure.core/map" "(meta #'my-hash-map)" "(meta #'*base-url*)" "(meta #'clojure.core/map)" "(ns-resolve 'clojure.core (symbol \"map\"))" "(ns-resolve 'clojure.core map)" " (let [fun \"my-hash-map\"] (meta (ns-resolve 'clojure.core (symbol fun))))" " (let [fun \"*base-url*\"] (meta (ns-resolve 'clojure.core (symbol fun))))" " (let [fun \"*base-url\"] (meta (ns-resolve 'clojure.core (symbol fun))))" " (let [fun \"map\"] (meta (ns-resolve 'clojure.core (symbol fun))))" "(use 'clojure.contrib.ns-utils)" "^#map" "^#'map" "^#'*base-url*" "b" "(def b (meta *base-url*))" "(println (meta my-hash-map))" "(println (meta *base-url*))" "(println (meta '*base-url*))" "*base-url*" "(meta '*base-url*)" "(meta *base-url*)" "(def ^:dynamic *base-url* \"https://news.ycombinator.com/\")" "meta" "(meta my-hash-map)" "meta my-hash-map" "^:dynamic my-hash-map" "meta my-hash-map" "my-hash-map" "(meta my-hash-map)" "(with-meta my-hash-map {:doc \"How mhm works!\"})" "(meta 'my-hash-map)" "(^:dynamic 'my-hash-map)" "(^:dynamic my-hash-map)" "(meta my-hash-map)" "^:dynamic my-hash-map" "(meta map)" "(meta my-hash-map)" "(+ 1 2 3 4 )" "(map)" "(take 1 '(a b c))" "(take 1 '(a b c)))" "(pos? 23)" "(seq '(a b c))" "'gutenmorgan" "'good-night-irene" "('mysy2m my-hash-map :erpa)" "('mysym my-hash-map :erpa)" "('mysym my-hash-map)" " (get my-hash-map 'mysym2 :erpa)" " (get my-hash-map 'mysym :erpa)" " (get my-hash-map 'mysym :none)" "(def my-hash-map {'mysym :none})" "(def my-hash-map 'mysym :none)" " (get my-hash-map 'mysym :none)" "(run-all-tests)" "(expect 23 24)" "(run-all-tests)" "(expect (barney) 23)" "(run-all-tests)" "(subvec [1 2 3] 1 4)" "(subvec [1 2 3] 1 3)" "(subvec [1 2 3] 1 2)" "(subvec [1 2 3] 1)" "barney" "(ns-name barney)" "(run-all-tests)" "(expect nil? nil)" "(barney)" "(gensym)" "(gensym \"erpa\")" "(gensym)" "(ns-name barney)" "(name a)" "(name barney)" "barney" "(barney)" "(namespace 'barney)" "(namespace barney)" "':foo" "(name :foo)" "(= :foo ':foo)" "(= (name :foo) \"foo\")" "a" "(def a 23)" "(identical? :foo :foo)" "(= :b :b)" "(run-all-tests)" "(expect nil? nil)" "(run-all-tests)" "(expect nil? nil)" "(barney)" "(* 1/3 21)" " " "(run-all-tests)" "(* 1/3 21)" "(if true 23)" "(if (= 22/7 22/7.0) 23)" "(if (= 22/7 22/7) 23)" "(if 0 23)" "(if true 23)" "(if false 23)" "(if nil 23)" "(= nil false)" "(= nil nil)" "(equal nil nil)" "(run-all-tests)" "(expect nil? 0)" "(expect nil? false)" "(expect nil? nil)" " (get my-hash-map 'mysym :none)" "('mysym my-hash-map :none) " "(def my-hash-map {:mysym :none})" " (get my-hash-map 'mysym :none)" "('mysym my-hash-map :none) " "{:a 1 :b 2}" "{:a 1 ;b 2}" "(1 2 3)" "[12 23]" "1e3" "1.0" ":erp" "\\a" "\"23\"" "1" "(run-all-tests)" "(expect 11 (barney))" "(exp/expect 11 (barney))" "(println \"erpa\" (barney))" "(barney)" "(run-all-tests)" "(expect 1 1)" "(ns new-stuf.core (:use expectations ))" "(run-all-tests)" "(expect 1 1)" "(ns new-stuf.core (:require [expectations :refer :all]))" "(ns new-stuf.core :require [expectations :refer :all])" "(ns new-stuf.core :use [expectations])" "(foo \"you\")" "(ns new-stuf.core)" "(foo \"you\")" "(ns fooey \"erpa katang\")" "(foo \"you\")" "(-main 23)" "(-main)" "(exp/run-all-tests)" "(exp/expect 11 (barney))" "(expect 1 2)" "(run-all-tests)" "(expect 1 2)" "(exp/run-all-tests)" "(exp/expect 11 (barney))" "(exp/run-all-tests)" "(exp/expect 23 (barney))" "(expect 23 (barney))" "(foo \"me\")" "(exp/run-all-tests)" "(exp/expect 3 (+ 1 1))" "(exp/run-all-tests)" "(exp/report (exp/run-all-tests))" "(exp/expect nil? nil)" "(exp/run-all-tests)" "(exp/expect nil? nil)" "(exp/expect nil? nill)" "(exp/run-all-tests)" "(exp/expect nil? 23)" "(exp/report (exp/run-all-tests))" "(exp/expect nil? 23)" "(exp/report (exp/run-all-tests))" "(exp/run-all-tests)" "(exp/report :summary(exp/expect nil? nil))" "(keys a)" "(:expectation a)" "a" "(def a (exp/expect nil? 23))" "(exp/expect nil? 23)" "(exp/expect nil? nil)" "(exp/report (exp/expect nil? nil))" "(exp/report)" "(exp/summary (exp/expect nil? nil))" "(exp/expected-message (exp/expect nil? nil))" "(exp/actual-message (exp/expect nil? nil))" "(exp/expect nil? nil)" "(java.util.Date.)" "(require '[markdown.core :as md] :verbose)" "(require '[alembic.still] :verbose)" "(require '[expectations :as exp] :verbose)" "(exp/expect nil? nil)" "(alembic.still/load-project)" "(exp/expect nil? nil)" "(exp/expect 1 2)" "(alembic.still/load-project)" "(exp/expect 1 2)" "(exp/expect 1 1)" "(ex/expect 1 1)" "(require '[expectations :as exp])" "(expect 1 1)" "(require '[expectations])" "(expect 1 1)" "(alembic.still/distill '[expectations \"2.0.7\"])" "(load-project)" "(require '[alembic.still])" "(expect 1 1)" "(require '[expectations.core])" "(require '[expectations])" "(load-project)" "
" "(require '[expectations.core])" "(require '[alembic.still])" "(expect 1 1)" "(require '[expectations])" "(load-project)" "(require '[alembic.core])" "(require '[alembic])" "(load-project)" "(md/md-to-html-string \"```clojure\\n(+ 1 3)\\n```\")" "(md/md-to-html-string \"#erpa\")" "(md/md-to-html-string \"# This is a test\\nsome code follows\\n```clojure\\n(defn foo [])\\n```\")" "(require '[markdown.core :as md])" "(require '[markdown-clj :as md])" "(require '[clj-http.client :as http])" "(md/md-to-html-string \"# This is a test\\nsome code follows\\n```clojure\\n(defn foo [])\\n```\")" "(+ 1 2 )" "(md-to-html-string \"# This is a test\\nsome code follows\\n```clojure\\n(defn foo [])\\n```\")" "(require '[markdown-clj.core :as md])" "(require '[markdown-clj :as md])" "(load-project)" "(require '[markdown-clj.core :as md])" "(-main \"ness\")" "(ns foo (:use markdown.core))" "(require '[markdown-clj :as md])" "(-main \"ness\")" "(println \"stuff\" a \"and stuff\")" "(filter #(< % 100) (map read-string (re-seq #\"[\\d]+\", (:date (:headers response)))))" "(filter #(< % 100) (re-seq #\"[\\d]+\", (:date (:headers response))))" "(re-seq #\"[\\d]+\", (:date (:headers response)))" "(re-seq #\"\\d+\", (:date (:headers response)))" "(re-seq #\"\\d\", (:date (:headers response)))" "(re-seq \"\\d\", (:date (:headers response)))" "(:date (:headers response))" "(:accept-ranges (:headers response))" "(:headers response)" "(:server (:headers response))" "(:server :headers response)" "(+ 1 2)" "(:request-time response)" "(:headers response)" "(:status response)" "(keys response)" "(print response)" "(doc keys)" "(doc map)" "(keys response)" "(print-simple a)" "(print-str a)" "(def a 1)" "(print a)" "(a)" "(def a 1)" "(foo \"you\")" "(the-ns foo)" "(ns-name 'user)" "(the-ns 'foo)" "(the-ns foo)" "(source foo)" "(the-ns -main)" "(the-ns '-main)" "(ns-name '-main)" "(ns-name 'clj-http.client)" "(ns-name '(the-ns 'clj-http.client))" "(ns-name '(the-ns 'clj-http))" "(ns-name 'clj-http)" "(ns-name 'user)" "(ns-name '[map])" "(ns-name [map])" "(ns-name map )" "(ns-name 'map )" "(ns-name 'doc )" "(ns-name [])" "(ns-name)" "(doc pprint)" "(get-ns)" "(clojuredocs pprint)" "(user/clojuredocs pprint)" "(doc pprint)" "(source -main)" "(doc map)" "(keys response)" "(def response (http/get \"http://foxjeff.com\"))" "(require '[clj-http.client :as http])" "(require '[clj-http.client as http])" "(+ 1 2)")